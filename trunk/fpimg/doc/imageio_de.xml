<?xml version="1.0" encoding="ISO8859-1"?>
<fpdoc-descriptions>

<!--
  ====================================================================
    ImageIO
  ====================================================================
-->

<module name="ImageIO">
<short>Bilddateien Lesen und Schreiben</short>
<descr>
<p>Die Unit <var>ImageIO</var> definiert einige Basisklassen für das allgemeine
Lesen und Schreiben von Bilddateien. Um ein spezielles Dateiformat zu
unterstützen, ist die entsprechende Basisklasse abzuleiten.</p>
<p>Derzeit wird nur das Lesen von Bildern unterstützt. Die entsprechende
Basisklasse heißt <link id="TImageReader"/>. Unterstützung für das Schreiben
von vorhandenen Bilddaten in eine Datei oder einen Stream wird in einer
zukünftigen Version hinzugefügt.</p>
<p>Diese Unit ist weitesgehendst unabhängig von anderen Paketen. Auch von fpGFX
werden nur Deklarationen übernommen, es wird aber kein Code verwendet. Dies
ermöglicht eine sehr flexible und effiziente Nutzung von <var>ImageIO</var>
für allerlei spezielle Anwendungen. Komfortfunktionen für die Nutzung mit
fpGFX sind in der Unit <link id="fpImg"/> zu finden.</p>
<p>fpImg ist (c) 2000 Areca Systems GmbH / Sebastian Günther
(sg@freepascal.org). Alle Rechte vorbehalten.</p>
</descr>

<element name="SysUtils">  <!-- Unit-Verweis -->
<short>Unterstützung für <link id="SysUtils.Exception">Exceptions</link></short>
</element>

<element name="Classes">  <!-- Unit-Verweis -->
<short>Unterstützung für <link id="Classes.TStream">Streams</link></short>
</element>

<element name="GFXBase">  <!-- Unit-Verweis -->
<short>Deklarationen für <link id="GFXBase.TGfxPixelFormat">Pixelformate</link>
und <link id="GFXBase.TGfxPalette">Farbpaletten</link></short>
</element>

<!--
  ********************************************************************
    EImgError
  ********************************************************************
-->

<element name="EImgError">  <!-- Klasse -->
<short>Allgemeine Fehler-Exception für <var>ImageIO</var></short>
<descr>
Alle speziellen Exceptions, die in <var>ImageIO</var> oder seinen Lese- und
Schreibroutinen auftreten können, sind von <var>EImgError</var> abgeleitet.
Diese Klasse betrifft allerdings nur spezifische Fehlersituationen; allgemeine
Fehlerbedingungen, wie Schutzverletzungen etc., werden über die gewohnten
Standard-Exceptions gemeldet.
</descr>
</element>

<!--
  ********************************************************************
    EImgOutOfData
  ********************************************************************
-->

<element name="EImgOutOfData">  <!-- Klasse -->
<short>Zuwenig Daten für Bild verfügbar</short>
<descr>
<p>Ein Bild-Lese-Objekt (<link id="TImageReader"/>) kann diesen Fehler melden,
wenn es Daten lesen soll, aber keine weiteren Daten zur Verfügung stehen.</p>
<p>Auf die Anforderung hin, Daten zu lesen, erwartet der Leser auch
entsprechende Daten. Es ist erforderlich, daß mindestens ein Byte an Daten zu
lesen ist. Ist dies nicht der Fall, wird diese Exception ausgelöst.</p>
</descr>
<seealso>
  <link id="TImageReader"/>
</seealso>
</element>

<element name="EImgOutOfData.Create">  <!-- Konstruktur -->
<short>Initialisierung mit passendem Fehlertext</short>
<descr>
Dieser Konstruktur dient nur zur bequemeren Programmierung: Er initialisiert
die Exception automatisch mit dem passenden Fehlertext.
</descr>
</element>

<!--
  ********************************************************************
    EImgUnsupportedPixelFormat
  ********************************************************************
-->

<element name="EImgUnsupportedPixelFormat">  <!-- Klasse -->
<short>Pixelformat wird nicht unterstützt</short>
<descr>
Diese Exception wird von Bildlese- oder Schreibklassen ausgelöst, wenn sie mit
einem Pixelformat konfrontiert werden, welches sie nicht unterstützen (Lesen)
oder nicht unterstützen können (zugrunde liegendes Dateiformat kennt das
geforderte Pixelformat nicht).
</descr>
</element>

<element name="EImgUnsupportedPixelFormat.Create">  <!-- Konstruktur -->
<short>Initialisierung mit passendem Fehlertext</short>
<descr>
Dieser Konstruktur dient nur zur bequemeren Programmierung: Er initialisiert
die Exception automatisch mit dem passenden Fehlertext.
</descr>
</element>

<element name="TImageReaderClass">  <!-- "class of" Typ -->
<short>Klassentyp für <link id="TImageReader"/></short>
<descr>
Diese Typdeklaration definiert einen Namen für alle Klassen vom Typ
<link id="TImageReader"/>. Um beispielsweise in einer Variable den Typ
einer Bildlese-Klasse zu speichern, muß diese Variable einfach als vom Typ
<var>TImageReaderClass</var> deklariert werden.
</descr>
<seealso>
  <link id="TImageReader"/>.
</seealso>
</element>

<element name="TImageReaderState">  <!-- Aufzählungstyp -->
<short>Zustandswerte für <link id="TImageReader">Bildleser</link></short>
<descr>
Dieser Typ zählt die verschiedenen möglichen Zustände für einen
<link id="TImageReader">Bildleser</link> auf. Während ein Bild eingelesen wird,
wird der Zustand an bestimmten Punkten um eine Stufe erhöht.
</descr>
<seealso>
  <link id="TImageReader"/>
</seealso>
</element>

<element name="TImageReaderState.irsStart">  <!-- Aufzählungswert -->
<short>Leser hat noch nichts getan</short>
</element>

<element name="TImageReaderState.irsInHeader">  <!-- Aufzählungswert -->
<short>Leser verarbeitet gerade den Header</short>
</element>

<element name="TImageReaderState.irsHeaderRead">  <!-- Aufzählungswert -->
<short>Leser hat den Header fertig eingelesen</short>
</element>

<element name="TImageReaderState.irsInImage">  <!-- Aufzählungswert -->
<short>Leser liest gerade die Bilddaten ein</short>
</element>

<element name="TImageReaderState.irsFinished">  <!-- Aufzählungswert -->
<short>Leser hat seine Arbeit beendet; Header und Bild sind komplett eingelesen.</short>
</element>

<element name="TSegmentEvent">  <!-- Prozedur-Typ -->
<short>'Segment gelesen' Ereignistyp</short>
<descr>
Dieser Typ definiert ein Ereignis, welches besagt, daß der Sender ein
Bildsegment erfolgreich fertig eingelesen hat. Die Argumente <var>StartY</var>
und <var>Height</var> geben Auskunft darüber, welchen Teil des gesamten Bildes
das gelesene Segment darstellt.
</descr>
<seealso>
  <link id="TImageReader.OnSegment"/>
</seealso>
</element>

<element name="TSegmentEvent.Sender">  <!-- Argument -->
<short>Auslöser des Ereignisses</short>
</element>

<element name="TSegmentEvent.StartY">  <!-- Argument -->
<short>Y-Start-Koordinate des Segmentes</short>
</element>

<element name="TSegmentEvent.Height">  <!-- Argument -->
<short>Höhe des Segmentes in Pixel</short>
</element>

<!--
  ********************************************************************
    TImageReader
  ********************************************************************
-->

<element name="TImageReader">  <!-- Klasse -->
<short>Basisklasse für Bildleser</short>
<descr>
<p>Diese Klasse stellt die Basisklasse für alle Bildleser dar. Wie der Name
sagt, ist ein Bildleser eine Klasse, welche Bilder (Images) einlesen kann.</p>
<p>Durch die gemeinsame Basisklasse gibt es eine gemeinsame Schnittstelle, so
daß verschiedene Leser in Anwendungen sehr leicht ausgetauscht werden können.
Für speziellere Anwendungen kann jeder Bildleser problemlos weitere Fähigkeiten
anbieten; hierbei entfällt dann aber der Vorteil der Austauschbarkeit.</p>
<p>Alle Daten werden aus einem <link id="Classes.TStream">Stream-Objekt</link>
geladen. Eine weitere Besonderheit ist die Anforderung an alle Leser, daß sie
asynchrones Lesen unterstützen müssen: Der Lesevorgang muß sich nach einer
beliebigen Zahl von gelesenen Bytes unterbrechen und zu einem späteren Zeitpunkt
wieder fortführen lassen.</p>

<section>
<title>Der Einlese-Vorgang aus der Sicht von außen</title>
<p>Die äußere Anwendung, welche den Leser verwenden will, sollte folgende Dinge
beachten:</p>

<ul>

<li><p>Zunächst wird der Header eingelesen. Dazu wird solange die Methode
<link id="TImageReader.ProcessHeaderData"/> aufgerufen, bis der Header
vollständig eingelesen wurde. Die Fertigstellung läßt sich über den aktuellen
Zustand (<link id="TImageReader.State"/>) oder über ein entsprechendes
Ereignis (<link id="TImageReader.OnHeader"/>) prüfen.</p></li>

<li><p>Die Anwendung kann nun entscheiden, ob sie die eigentlichen Bilddaten
lesen will oder nicht. Ein Abbrechen an dieser Stelle ist problemlos
möglich. Desweiteren können ab diesem Zeitpunkt die Eigenschaften des Bildes
über die entsprechenden Eigenschaften des Objekts abgefragt werden.</p></li>

<li><p>Das Bild selbst kann auf Wunsch in mehreren Schritten, sogenannten
<em>Segmenten</em> eingelesen werden. Ein Segment ist einfach ein vertikaler
Abschnitt des Bildes.<br/>Ein Segment muß initialisiert werden, und zwar zu
Beginn des Einlese-Vorgangs und, auf Wunsch, nachdem ein einzelnes Segment
fertig gelesen wurde. Hierzu dient die Methode
<link id="TImageReader.SetImageSegmentBuffer"/>. Bemerkenswert hierbei ist,
daß der Aufrufer den Speicher für das Bild verwaltet.</p></li>

<li><p>Um herauszufinden, an welcher Stelle das nächste zu lesende Segment
liegen wird, sollte die Methode <link id="TImageReader.GetImageSegmentStartY"/>
befragt werden. Dies ist nur dann nicht notwendig, falls das Bild in nur einem
Segment gelesen werden soll - hier würde immer der Wert "0" zurückgeliefert
werden.</p></li>

<li><p>Wenn der Leser Bilddaten lesen soll, ist dazu einfach die Methode
<link id="TImageReader.ProcessImageData"/> aufzurufen. Diese Methode liest
solange Daten, solange welche verfügbar sind oder das Bild fertig eingelesen
wurde.</p></li>

<li><p>Sobald ein Segment fertig gelesen wurde, wird das Ereignis
<link id="TImageReader.OnSegment"/> ausgelöst.</p></li>

<li><p>Wurde das gesamte Bild fertig eingelesen, wird das Ereignis
<link id="TImageReader.OnImage"/> ausgelöst.</p></li>

</ul>
</section>

<section>
<title>Der Einlese-Vorgang aus der Sicht des Lesers</title>
<p>Für die Implementierung von abgeleitete Klassen, welche ein konkretes
Bildformat lesen können, sind folgende Punkte zu beachten:</p>
<ul>
<li><p>Üblicherweise wird kein neuer <link id="TImageReader.Create">Konstruktur
</link> benötigt. Es spricht zwar auch nichts dagegen; aber die Präsenz eines
virtuellen Konstruktors in dieser Basisklasse mag für manchen so erscheinen,
als sei dies notwendig. Dies ist nicht der Fall.</p></li>
<li><p>Die Verwaltung des aktuellen Zustandes (<link id="TImageReader.State"/>)
wird bereits komplett von der Basisklasse übernommen</p></li>
<li><p>Die Methode <link id="TImageReader.DoProcessHeaderData"/> muß auf jeden
Fall überschrieben werden; sie dient zum Lesen und zur Auswertung des
Bild-Headers. Sobald der Header fertig eingelesen wurde und die entsprechenden
Informations-Eigenschaften gesetzt wurden, muß die neue Methode die Methode
<link id="TImageReader.HeaderFinished"/> aufrufen.</p></li>
<li><p>Die Methode <link id="TImageReader.DoGetImageSegmentStartY"/> muß
überschrieben werden; sie kann vor dem Lesen eines Segmentes aufgerufen werden,
solange es noch Segmente zu lesen gibt.</p></li>
<li><p>Die Methode <link id="TImageReader.InitImageReading"/> kann überschrieben
werden, wenn der Bildleser vor Beginn des Einlesens der eigentlichen Bilddaten
noch spezielle Vorbereitungen zu treffen hat.</p></li>
<li><p>Die Methode <link id="TImageReader.DoProcessHeaderData"/> wird in
abgeleiteten Klassen überschrieben, um Bilddaten einlesen zu können. Immer dann,
wenn ein Segment eingelesen wurde, muß die neue Methode die Methode
<link id="TImageReader.SegmentFinished"/> aufrufen; entsprechend muß
<link id="TImageReader.ImageFinished"/> aufgerufen werden, sobald das Bild
vollständig eingelesen wurde.</p></li>
</ul>
</section>
</descr>

<errors>
Trifft der Leser im Header auf ein Pixelformat, welches er nicht verarbeiten
kann, so löst er eine <link id="EImgUnsupportedPixelFormat"/> Exception aus.
<br/>
Wird <link id="TImageReader.ProcessHeaderData"/> oder
<link id="TImageReader.ProcessImageData"/> aufgerufen und es können vom
Eingabe-Datenstrom keine Daten gelesen werden, so wird die Exception
<link id="EImgOutOfData"/> ausgelöst.
</errors>
</element>

<element name="TImageReader.FWidth">  <!-- Variable -->
<short>Breite des Bildes</short>
<descr>
Dieses Feld gibt die Breite des Bildes in Pixeln an. Es darf nur innerhalb von
<link id="TImageReader.DoProcessHeaderData"/> gesetzt werden.
</descr>
<seealso>
  <link id="TImageReader.Width"/>
</seealso>
</element>

<element name="TImageReader.FHeight">  <!-- Variable -->
<short>Höhe des Bildes</short>
<descr>
Dieses Feld gibt die Höhe des Bildes in Pixeln an. Es darf nur innerhalb von
<link id="TImageReader.DoProcessHeaderData"/> gesetzt werden.
</descr>
<seealso>
  <link id="TImageReader.Height"/>
</seealso>
</element>

<element name="TImageReader.FPixelFormat">  <!-- Variable -->
<short>Pixelformat des Bildes</short>
<descr>
Dieses Feld beschreibt das Pixelformat, in welchem die Pixeldaten
vorliegen. Es darf nur innerhalb von
<link id="TImageReader.DoProcessHeaderData"/> gesetzt werden.
</descr>
<seealso>
  <link id="TImageReader.PixelFormat"/>
</seealso>
</element>

<element name="TImageReader.HeaderFinished">  <!-- Prozedur -->
<short>Signalisierung: Header fertig eingelesen</short>
<descr>
<p>Diese Methode wird von abgeleiteten Klassen aufgerufen, sobald diese den
Header des Bildes fertig eingelesen und verarbeitet haben. Der Zustand des
Lesers wird auf <link id="TImageReaderState.irsHeaderFinished"/> gesetzt, und
die Behandlungsroutine des Ereignisses <link id="TImageReader.OnHeader"/> wird
aufgerufen, falls vorhanden.</p>
<p><var>HeaderFinished</var> darf nur von überschriebenen Methoden von
<link id="TImageReader.DoProcessHeaderData"/> aufgerufen werden; der Leser
befindet sich zu diesem Zeitpunkt noch im Zustand
<link id="TImageReaderState.irsInHeader"/>.</p>
</descr>
<errors>
Nur Debug-Version: Prüft per Zusicherung auf korrekten Zustand des Lesers.
</errors>
<seealso>
  <link id="TImageReader.ProcessHeaderData"/>
  <link id="TImageReader.DoProcessHeaderData"/>
</seealso>
</element>

<element name="TImageReader.SegmentFinished">  <!-- Prozedur -->
<short>Signalisierung: Bildsegment eingelesen</short>
<descr>
<p>Abgeleitete Klassen rufen diese Methode auf, um zu signalisieren, daß ein
Segment des Bildes fertig eingelesen wurde. Falls vorhanden, wird die
Behandlungsroutine des Ereignisses <link id="TImageReader.OnSegment"/>
aufgerufen.</p>
<p><var>SegmentFinished</var> darf nur von überschriebenen Methoden von
<link id="TImageReader.DoProcessImageData"/> aufgerufen werden; der Leser
befindet sich zu diesem Zeitpunkt immer im Zustand
<link id="TImageReaderState.irsInImage"/>.</p>
</descr>
<errors>
Nur Debug-Version: Prüft per Zusicherung auf korrekten Zustand des Lesers.
</errors>
</element>

<element name="TImageReader.SegmentFinished.AStartY">  <!-- Argument -->
<short>Y-Start-Koordinate des Segmentes</short>
</element>

<element name="TImageReader.SegmentFinished.AHeight">  <!-- Argument -->
<short>Höhe des Segments in Pixel</short>
</element>

<element name="TImageReader.ImageFinished">  <!-- Prozedur -->
<short>Signalisierung: Bild fertig eingelesen</short>
<descr>
<p>Eine abgeleitete Klasse ruft diese Methode auf, um anzuzeigen, daß das
gesamte Bild nun eingelesen wurde. Der Zustand des Lesers wird auf
<link id="TImageReaderState.irsFinished"/> gesetzt, und die Behandlungsroutine
für das Ereignis <link id="TImageReader.OnImage"/> wird aufgerufen, falls diese
gesetzt ist.</p>
<p><var>ImageFinished</var> darf nur von überschriebenen Methoden von
<link id="TImageReader.DoProcessImageData"/> aufgerufen werden; der Leser
befindet sich zu diesem Zeitpunkt noch im Zustand
<link id="TImageReaderState.irsInImage"/>.</p>
</descr>
<errors>
Nur Debug-Version: Prüft per Zusicherung auf korrekten Zustand des Lesers.
</errors>
</element>

<element name="TImageReader.DoProcessHeaderData">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoProcessHeaderData.AStream">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoGetImageSegmentStartY">  <!-- Funktion -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoGetImageSegmentStartY.Result">  <!-- Funktionsergebnis -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoGetImageSegmentStartY.ASegmentHeight">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.InitImageReading">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoProcessImageData">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.DoProcessImageData.AStream">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.Create">  <!-- Konstruktur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.ProcessHeaderData">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.ProcessHeaderData.AStream">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.GetImageSegmentStartY">  <!-- Funktion -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.GetImageSegmentStartY.Result">  <!-- Funktionsergebnis -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.GetImageSegmentStartY.ASegmentHeight">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SetImageSegmentBuffer">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SetImageSegmentBuffer.AData">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SetImageSegmentBuffer.AStride">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SetImageSegmentBuffer.ASegmentHeight">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.ProcessImageData">  <!-- Prozedur -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.ProcessImageData.AStream">  <!-- Argument -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.State">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.Width">  <!-- Eigenschaft -->
<short>Breite des Bildes</short>
<descr>
Diese Eigenschaft gibt die Breite des Bildes in Pixeln an. Sie wird im Rahmen
des Header-Einlesens gesetzt und besitzt ab dem Zustand
<link id="TImageReaderState.irsHeaderFinished"/> einen gültigen (und
endgültigen) Wert.
</descr>
<seealso>
  <link id="TImageReader.FWidth"/>
</seealso>
</element>

<element name="TImageReader.Height">  <!-- Eigenschaft -->
<short>Höhe des Bildes</short>
<descr>
Diese Eigenschaft gibt die Höhe des Bildes in Pixeln an. Sie wird im Rahmen
des Header-Einlesens gesetzt und besitzt ab dem Zustand
<link id="TImageReaderState.irsHeaderFinished"/> einen gültigen (und
endgültigen) Wert.
</descr>
<seealso>
  <link id="TImageReader.FHeight"/>
</seealso>
</element>

<element name="TImageReader.PixelFormat">  <!-- Eigenschaft -->
<short>Pixelformat des Bildes</short>
<descr>
Diese Eigenschaft beschreibt das Pixelformat, in welchem die Pixeldaten
vorliegen. Sie wird im Rahmen des Header-Einlesens gesetzt und besitzt ab dem
Zustand <link id="TImageReaderState.irsHeaderFinished"/> einen gültigen (und
endgültigen) Wert.
</descr>
<seealso>
  <link id="GFXBase.TGfxPixelFormat"/>
  <link id="TImageReader.FPixelFormat"/>
</seealso>
</element>

<element name="TImageReader.SegmentData">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SegmentStride">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SegmentHeight">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.SegmentSize">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.OnHeader">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.OnSegment">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="TImageReader.OnImage">  <!-- Eigenschaft -->
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>
</module> <!-- ImageIO -->
</fpdoc-descriptions>
