diff -u -p -r gdb/breakpoint.c origdb/breakpoint.c
--- gdb/breakpoint.c	2002-09-16 11:46:19.000000000 +0200
+++ origdb/breakpoint.c	2002-09-16 10:23:54.000000000 +0200
@@ -720,19 +720,7 @@ insert_breakpoints (void)
     if (b->enable_state == bp_permanent)
       /* Permanent breakpoints cannot be inserted or removed.  */
       continue;
-    if ((b->type == bp_watchpoint
-	 || b->type == bp_hardware_watchpoint
-	 || b->type == bp_read_watchpoint
-	 || b->type == bp_access_watchpoint) && (!b->val))
-      {
-	struct value *val;
-	val = evaluate_expression (b->exp);
-	release_value (val);
-	if (VALUE_LAZY (val))
-	  value_fetch_lazy (val);
-	b->val = val;
-      } 
-    if (b->type != bp_watchpoint
+    else if (b->type != bp_watchpoint
 	&& b->type != bp_hardware_watchpoint
 	&& b->type != bp_read_watchpoint
 	&& b->type != bp_access_watchpoint
@@ -1472,13 +1460,6 @@ breakpoint_init_inferior (enum inf_conte
 	/* Likewise for watchpoints on local expressions.  */
 	if (b->exp_valid_block != NULL)
 	  delete_breakpoint (b);
-	if (context == inf_starting) 
-	  {
-	    /* Reset val field to force reread of starting value in insert_breakpoints.  */
-	    if (b->val)
-	      value_free (b->val);
-	    b->val = NULL;
-	  }
 	break;
       default:
 	/* Likewise for exception catchpoints in dynamic-linked
Only in gdb: breakpoint.c.orig
diff -u -p -r gdb/config/i386/nm-i386.h origdb/config/i386/nm-i386.h
--- gdb/config/i386/nm-i386.h	2002-09-16 11:40:22.000000000 +0200
+++ origdb/config/i386/nm-i386.h	2002-09-16 10:24:02.000000000 +0200
@@ -115,10 +115,6 @@ extern int  i386_remove_hw_breakpoint (C
 
 #define DECR_PC_AFTER_HW_BREAK 0
 
-/* child_post_startup_inferior used to
-   reset all debug registers by calling i386_cleanup_dregs ().  */ 
-#define CHILD_POST_STARTUP_INFERIOR
-
 #endif /* I386_USE_GENERIC_WATCHPOINTS */
 
 #endif /* NM_I386_H */
diff -u -p -r gdb/i386-nat.c origdb/i386-nat.c
--- gdb/i386-nat.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/i386-nat.c	2002-09-16 10:24:39.000000000 +0200
@@ -230,14 +230,6 @@ i386_cleanup_dregs (void)
   dr_status_mirror  = 0;
 }
 
-/* Reset all debug registers at each new startup
-   to avoid missing watchpoints after restart.  */
-void
-child_post_startup_inferior (ptid_t ptid)
-{
-  i386_cleanup_dregs ();
-}
-
 /* Print the values of the mirrored debug registers.
    This is called when maint_show_dr is non-zero.  To set that
    up, type "maint show-debug-regs" at GDB's prompt.  */
diff -u -p -r gdb/i386-tdep.c origdb/i386-tdep.c
--- gdb/i386-tdep.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/i386-tdep.c	2002-09-16 10:24:39.000000000 +0200
@@ -690,8 +690,6 @@ i386_skip_prologue (int pc)
 {
   unsigned char op;
   int i;
-  CORE_ADDR last_push_esi_pos = 0;
-
   static unsigned char pic_pat[6] =
   { 0xe8, 0, 0, 0, 0,		/* call   0x0 */
     0x5b,			/* popl   %ebx */
@@ -711,9 +709,7 @@ i386_skip_prologue (int pc)
       /* Break if not `pushl' instrunction.  */
       if (op < 0x50 || op > 0x57)
 	break;
-      if (op == 0x56)
-	last_push_esi_pos = codestream_tell ();
-      codestream_get();
+      codestream_get ();
     }
 
   /* The native cc on SVR4 in -K PIC mode inserts the following code
@@ -769,10 +765,7 @@ i386_skip_prologue (int pc)
 
   i386_follow_jump ();
 
-  if (codestream_tell () == last_push_esi_pos + 1)
-    return (last_push_esi_pos);
-  else
-    return (codestream_tell ());
+  return (codestream_tell ());
 }
 
 void
diff -u -p -r gdb/p-exp.y origdb/p-exp.y
--- gdb/p-exp.y	2002-09-16 11:40:22.000000000 +0200
+++ origdb/p-exp.y	2002-09-16 10:24:52.000000000 +0200
@@ -50,7 +50,7 @@ Foundation, Inc., 59 Temple Place - Suit
 #include "gdb_string.h"
 #include <ctype.h>
 #include "expression.h"
-#include "value.h" 
+#include "value.h"
 #include "parser-defs.h"
 #include "language.h"
 #include "p-lang.h"
@@ -151,14 +151,9 @@ static char * uptok (char *, int);
 /* YYSTYPE gets defined by %union */
 static int
 parse_number (char *, int, int, YYSTYPE *);
-
-static struct type * current_type;
-static void push_current_type ();
-static void pop_current_type ();
-static int search_field;
 %}
 
-%type <voidval> exp exp1 type_exp start normal_start variable qualified_name
+%type <voidval> exp exp1 type_exp start variable qualified_name
 %type <tval> type typebase
 /* %type <bval> block */
 
@@ -176,8 +171,7 @@ static int search_field;
    Contexts where this distinction is not important can use the
    nonterminal "name", which matches either NAME or TYPENAME.  */
 
-%token <sval> STRING 
-%token <sval> FIELDNAME
+%token <sval> STRING
 %token <ssym> NAME /* BLOCKNAME defined below to give it higher precedence. */
 %token <tsym> TYPENAME
 %type <sval> name
@@ -218,7 +212,6 @@ static int search_field;
 %left '*' '/'
 %right UNARY INCREMENT DECREMENT
 %right ARROW '.' '[' '('
-%right '^'
 %token <ssym> BLOCKNAME
 %type <bval> block
 %left COLONCOLON
@@ -226,21 +219,15 @@ static int search_field;
 
 %%
 
-start   :	{ current_type = NULL;
-		  search_field = 0;
-		}
-		normal_start;
-
-normal_start	:
-		exp1
+start   :	exp1
 	|	type_exp
 	;
 
 type_exp:	type
 			{ write_exp_elt_opcode(OP_TYPE);
 			  write_exp_elt_type($1);
-			  write_exp_elt_opcode(OP_TYPE);
-			  current_type = $1; } ;
+			  write_exp_elt_opcode(OP_TYPE);}
+	;
 
 /* Expressions, including the comma operator.  */
 exp1	:	exp
@@ -250,14 +237,11 @@ exp1	:	exp
 
 /* Expressions, not including the comma operator.  */
 exp	:	exp '^'   %prec UNARY
-			{ write_exp_elt_opcode (UNOP_IND);
-			  if (current_type) 
-			    current_type = TYPE_TARGET_TYPE (current_type); }
-	;
-exp	:	'@' exp    %prec UNARY { write_exp_elt_opcode (UNOP_ADDR); 
-			  if (current_type)
-			    current_type = TYPE_POINTER_TYPE (current_type); }
-	;
+			{ write_exp_elt_opcode (UNOP_IND); }
+
+exp	:	'@' exp    %prec UNARY
+			{ write_exp_elt_opcode (UNOP_ADDR); }
+
 exp	:	'-' exp    %prec UNARY
 			{ write_exp_elt_opcode (UNOP_NEG); }
 	;
@@ -274,55 +258,24 @@ exp	:	DECREMENT  '(' exp ')'   %prec UNA
 			{ write_exp_elt_opcode (UNOP_PREDECREMENT); }
 	;
 
-exp	:	exp '.' { search_field = 1; } 
-		FIELDNAME 
-		/* name */
+exp	:	exp '.' name
 			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  write_exp_string ($4); 
-			  write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  search_field = 0; 
-			  if (current_type)
-			    { while (TYPE_CODE (current_type) == TYPE_CODE_PTR)
-				current_type = TYPE_TARGET_TYPE (current_type);
-			      current_type = lookup_struct_elt_type (
-				current_type, $4.ptr, false); };
-			 } ; 
-exp	:	exp '['
-			/* We need to save the current_type value */
-			{ char *arrayname; 
-			  int arrayfieldindex;
-			  arrayfieldindex = is_pascal_string_type (
-				current_type, NULL, NULL,
-				NULL, NULL, &arrayname); 
-			  if (arrayfieldindex) 
-			    {
-			      struct stoken stringsval;
-			      stringsval.ptr = alloca (strlen (arrayname) + 1);
-			      stringsval.length = strlen (arrayname);
-			      strcpy (stringsval.ptr, arrayname);
-			      current_type = TYPE_FIELD_TYPE (current_type,
-				arrayfieldindex - 1); 
-			      write_exp_elt_opcode (STRUCTOP_STRUCT);
-			      write_exp_string (stringsval); 
-			      write_exp_elt_opcode (STRUCTOP_STRUCT);
-			    }
-			  push_current_type ();  }
-		exp1 ']'
-			{ pop_current_type ();
-			  write_exp_elt_opcode (BINOP_SUBSCRIPT);
-			  if (current_type)
-			    current_type = TYPE_TARGET_TYPE (current_type); }
+			  write_exp_string ($3);
+			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
+	;
+
+exp	:	exp '[' exp1 ']'
+			{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
+	;
 
 exp	:	exp '('
 			/* This is to save the value of arglist_len
 			   being accumulated by an outer function call.  */
-			{ push_current_type ();
-			  start_arglist (); }
+			{ start_arglist (); }
 		arglist ')'	%prec ARROW
 			{ write_exp_elt_opcode (OP_FUNCALL);
 			  write_exp_elt_longcst ((LONGEST) end_arglist ());
-			  write_exp_elt_opcode (OP_FUNCALL); 
-			  pop_current_type (); }
+			  write_exp_elt_opcode (OP_FUNCALL); }
 	;
 
 arglist	:
@@ -335,8 +288,7 @@ arglist	:
 exp	:	type '(' exp ')' %prec UNARY
 			{ write_exp_elt_opcode (UNOP_CAST);
 			  write_exp_elt_type ($1);
-			  write_exp_elt_opcode (UNOP_CAST); 
-			  current_type = $1; }
+			  write_exp_elt_opcode (UNOP_CAST); }
 	;
 
 exp	:	'(' exp1 ')'
@@ -615,11 +567,9 @@ variable:	name_not_typename
 			      write_exp_elt_block (NULL);
 			      write_exp_elt_sym (sym);
 			      write_exp_elt_opcode (OP_VAR_VALUE);
-			      current_type = sym->type; }
+			    }
 			  else if ($1.is_a_field_of_this)
 			    {
-			      struct value * this_val;
-			      struct type * this_type;
 			      /* Object pascal: it hangs off of `this'.  Must
 			         not inadvertently convert from a method call
 				 to data ref.  */
@@ -631,18 +581,6 @@ variable:	name_not_typename
 			      write_exp_elt_opcode (STRUCTOP_PTR);
 			      write_exp_string ($1.stoken);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
-			      /* we need type of this */
-			      this_val = value_of_this (0); 
-			      if (this_val)
-				this_type = this_val->type;
-			      else
-				this_type = NULL;
-			      if (this_type)
-				current_type = lookup_struct_elt_type (
-				  this_type,
-				  $1.stoken.ptr, false);
-			      else
-				current_type = NULL; 
 			    }
 			  else
 			    {
@@ -943,36 +881,6 @@ parse_number (p, len, parsed_float, puti
    return INT;
 }
 
-
-struct type_push
-{
-  struct type *stored;
-  struct type_push *next;
-};
-
-static struct type_push *tp_top = NULL;
-
-static void push_current_type ()
-{
-  struct type_push *tpnew;
-  tpnew = (struct type_push *) malloc (sizeof (struct type_push));
-  tpnew->next = tp_top;
-  tpnew->stored = current_type;
-  current_type = NULL;
-  tp_top = tpnew; 
-}
-
-static void pop_current_type ()
-{
-  struct type_push *tp = tp_top;
-  if (tp)
-    {
-      current_type = tp->stored;
-      tp_top = tp->next;
-      xfree (tp);
-    }
-}
-
 struct token
 {
   char *operator;
@@ -999,8 +907,8 @@ static const struct token tokentab2[] =
     {"<>", NOTEQUAL, BINOP_END},
     {"<=", LEQ, BINOP_END},
     {">=", GEQ, BINOP_END},
-    {":=", ASSIGN, BINOP_END},
-    {"::", COLONCOLON, BINOP_END} };
+    {":=", ASSIGN, BINOP_END}
+  };
 
 /* Allocate uppercased var */
 /* make an uppercased copy of tokstart */
@@ -1239,7 +1147,6 @@ yylex ()
 	  {
 	    tempbuf = (char *) realloc (tempbuf, tempbufsize += 64);
 	  }
-
 	switch (*tokptr)
 	  {
 	  case '\0':
@@ -1386,47 +1293,33 @@ yylex ()
     char *tmp = copy_name (yylval.sval);
     struct symbol *sym;
     int is_a_field_of_this = 0;
-    int is_a_field = 0;
     int hextype;
 
-
-    if (search_field && current_type)
-      is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);	
-    if (is_a_field)
-      sym = NULL;
-    else
-      sym = lookup_symbol (tmp, expression_context_block,
-			   VAR_NAMESPACE,
-			   &is_a_field_of_this,
-			   (struct symtab **) NULL);
-
+    sym = lookup_symbol (tmp, expression_context_block,
+			 VAR_NAMESPACE,
+			 &is_a_field_of_this,
+			 (struct symtab **) NULL);
     /* second chance uppercased (as Free Pascal does).  */
-    if (!sym && !is_a_field_of_this && !is_a_field)
+    if (!sym && !is_a_field_of_this)
       {
        for (i = 0; i <= namelen; i++)
          {
            if ((tmp[i] >= 'a' && tmp[i] <= 'z'))
              tmp[i] -= ('a'-'A');
          }
-       if (search_field && current_type)
-	 is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);	
-       if (is_a_field)
-	 sym = NULL;
-       else
-	 sym = lookup_symbol (tmp, expression_context_block,
+       sym = lookup_symbol (tmp, expression_context_block,
                         VAR_NAMESPACE,
                         &is_a_field_of_this,
                         (struct symtab **) NULL);
-       if (sym || is_a_field_of_this || is_a_field)
+       if (sym || is_a_field_of_this)
          for (i = 0; i <= namelen; i++)
            {
              if ((tokstart[i] >= 'a' && tokstart[i] <= 'z'))
                tokstart[i] -= ('a'-'A');
            }
       }
-
     /* Third chance Capitalized (as GPC does).  */
-    if (!sym && !is_a_field_of_this && !is_a_field)
+    if (!sym && !is_a_field_of_this)
       {
        for (i = 0; i <= namelen; i++)
          {
@@ -1439,17 +1332,11 @@ yylex ()
            if ((tmp[i] >= 'A' && tmp[i] <= 'Z'))
              tmp[i] -= ('A'-'a');
           }
-
-       if (search_field && current_type)
-	 is_a_field = (lookup_struct_elt_type (current_type, tmp, 1) != NULL);	
-       if (is_a_field)
-	 sym = NULL;
-       else
-	 sym = lookup_symbol (tmp, expression_context_block,
+       sym = lookup_symbol (tmp, expression_context_block,
                          VAR_NAMESPACE,
                          &is_a_field_of_this,
                          (struct symtab **) NULL);
-       if (sym || is_a_field_of_this || is_a_field)
+        if (sym || is_a_field_of_this)
           for (i = 0; i <= namelen; i++)
             {
               if (i == 0)
@@ -1462,26 +1349,6 @@ yylex ()
                   tokstart[i] -= ('A'-'a');
             }
       }
-
-    if (is_a_field)
-      {
-	tempbuf = (char *) realloc (tempbuf, namelen + 1);
-	strncpy (tempbuf, tokstart, namelen); tempbuf [namelen] = 0;
-	yylval.sval.ptr = tempbuf;
-	yylval.sval.length = namelen; 
-	return FIELDNAME;
-      } 
-
-    /* if not found uppercase the whole.  */
-    if (!sym && !is_a_field_of_this)
-      {
-       for (i = 0; i <= namelen; i++)
-         {
-           if ((tokstart[i] >= 'a' && tokstart[i] <= 'z'))
-              tokstart[i] -= ('a'-'A');
-          }
-      }
-
     /* Call lookup_symtab, not lookup_partial_symtab, in case there are
        no psymtabs (coff, xcoff, or some future change to blow away the
        psymtabs once once symbols are read).  */
@@ -1610,7 +1477,8 @@ yylex ()
   }
 }
 
-void yyerror (msg)
+void
+yyerror (msg)
      char *msg;
 {
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
diff -u -p -r gdb/p-lang.c origdb/p-lang.c
--- gdb/p-lang.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/p-lang.c	2002-09-16 10:24:52.000000000 +0200
@@ -44,8 +44,7 @@ extern void _initialize_pascal_language 
    but this does not happen for Free Pascal nor for GPC.  */
 int
 is_pascal_string_type (struct type *type,int *length_pos,
-                       int *length_size, int *string_pos, int *char_size,
-		       char **arrayname)
+                       int * length_size, int *string_pos, int *char_size)
 {
   if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
     {
@@ -55,17 +54,11 @@ is_pascal_string_type (struct type *type
           && strcmp (TYPE_FIELDS (type)[0].name, "length") == 0 
           && strcmp (TYPE_FIELDS (type)[1].name, "st") == 0)
         {
-          if (length_pos)
-	    *length_pos = TYPE_FIELD_BITPOS (type, 0) / TARGET_CHAR_BIT;
-          if (length_size)
-	    *length_size = TYPE_FIELD_TYPE (type, 0)->length;
-          if (string_pos)
-	    *string_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
-          if (char_size)
-	    *char_size = 1;
- 	  if (arrayname)
-	    *arrayname = TYPE_FIELDS (type)[1].name;
-         return 2;
+          *length_pos = TYPE_FIELD_BITPOS (type, 0) / TARGET_CHAR_BIT;
+          *length_size = TYPE_FIELD_TYPE (type, 0)->length;
+          *string_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
+          *char_size = 1;
+          return 1;
         };
       /* GNU pascal strings.  */
       /* Three fields: Capacity, length and schema$ or _p_schema.  */
@@ -73,18 +66,12 @@ is_pascal_string_type (struct type *type
           && strcmp (TYPE_FIELDS (type)[0].name, "Capacity") == 0
           && strcmp (TYPE_FIELDS (type)[1].name, "length") == 0)
         {
-          if (length_pos)
-	    *length_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
-          if (length_size)
-	    *length_size = TYPE_FIELD_TYPE (type, 1)->length;
-          if (string_pos)
-	    *string_pos = TYPE_FIELD_BITPOS (type, 2) / TARGET_CHAR_BIT;
+          *length_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;
+          *length_size = TYPE_FIELD_TYPE (type, 1)->length;
+          *string_pos = TYPE_FIELD_BITPOS (type, 2) / TARGET_CHAR_BIT;
           /* FIXME: how can I detect wide chars in GPC ?? */
-          if (char_size)
-	    *char_size = 1;
- 	  if (arrayname)
-	    *arrayname = TYPE_FIELDS (type)[1].name;
-         return 2;
+          *char_size = 1;
+          return 1;
         };
     }
   return 0;
@@ -293,7 +280,7 @@ pascal_create_fundamental_type (struct o
 			0, "void", objfile);
       break;
     case FT_CHAR:
-      type = init_type (TYPE_CODE_CHAR,
+      type = init_type (TYPE_CODE_INT,
 			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
 			0, "char", objfile);
       break;
diff -u -p -r gdb/p-lang.h origdb/p-lang.h
--- gdb/p-lang.h	2002-09-16 11:40:22.000000000 +0200
+++ origdb/p-lang.h	2002-09-16 10:24:52.000000000 +0200
@@ -38,8 +38,7 @@ extern void pascal_type_print_method_arg
 
 /* These are in p-lang.c: */
 
-extern int 
-  is_pascal_string_type (struct type *, int *, int *, int *, int *, char **);
+extern int is_pascal_string_type (struct type *, int *, int *, int *, int*);
 
 extern void pascal_printchar (int, struct ui_file *);
 
diff -u -p -r gdb/p-valprint.c origdb/p-valprint.c
--- gdb/p-valprint.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/p-valprint.c	2002-09-16 10:24:52.000000000 +0200
@@ -191,7 +191,7 @@ pascal_val_print (struct type *type, cha
 	     Pascal strings are mapped to records
 	     with lowercase names PM  */
           if (is_pascal_string_type (elttype, &length_pos,
-                                     &length_size, &string_pos, &char_size, NULL)
+                                     &length_size, &string_pos, &char_size)
 	      && addr != 0)
 	    {
 	      ULONGEST string_length;
@@ -320,7 +320,7 @@ pascal_val_print (struct type *type, cha
       else
 	{
           if (is_pascal_string_type (type, &length_pos, &length_size,
-                                     &string_pos, &char_size, NULL))
+                                     &string_pos, &char_size))
 	    {
 	      len = extract_unsigned_integer (valaddr + embedded_offset + length_pos, length_size);
 	      LA_PRINT_STRING (stream, valaddr + embedded_offset + string_pos, len, char_size, 0);
diff -u -p -r gdb/top.c origdb/top.c
--- gdb/top.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/top.c	2002-09-16 10:25:37.000000000 +0200
@@ -1325,7 +1325,7 @@ print_gdb_version (struct ui_file *strea
      program to parse, and is just canonical program name and version
      number, which starts after last space. */
 
-  fprintf_filtered (stream, "GNU gdb %s adapted to Free Pascal\n", version);
+  fprintf_filtered (stream, "GNU gdb %s\n", version);
 
   /* Second line is a copyright notice. */
 
diff -u -p -r gdb/win32-nat.c origdb/win32-nat.c
--- gdb/win32-nat.c	2002-09-16 11:40:22.000000000 +0200
+++ origdb/win32-nat.c	2002-09-16 10:25:41.000000000 +0200
@@ -81,13 +81,6 @@ static unsigned dr[8];
 static int debug_registers_changed = 0;
 static int debug_registers_used = 0;
 
-#ifdef HAVE_SSE_REGS
-#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
-	| CONTEXT_EXTENDED_REGISTERS
-#else
-#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS
-#endif
-
 /* The string sent by cygwin when it processes a signal.
    FIXME: This should be in a cygwin include file. */
 #define CYGWIN_SIGNAL_STRING "cygwin: signal"
@@ -293,22 +286,6 @@ child_add_thread (DWORD id, HANDLE h)
   th->h = h;
   th->next = thread_head.next;
   thread_head.next = th;
-  /* Set the debug registers for the new thread in they are used.  */
-  if (debug_registers_used)
-    {
-      /* Only change the value of the debug registers.  */
-      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
-      CHECK (GetThreadContext (th->h, &th->context));
-      th->context.Dr0 = dr[0];
-      th->context.Dr1 = dr[1];
-      th->context.Dr2 = dr[2];
-      th->context.Dr3 = dr[3];
-      /* th->context.Dr6 = dr[6];
-      FIXME: should we set dr6 also ?? */
-      th->context.Dr7 = dr[7];
-      CHECK (SetThreadContext (th->h, &th->context));
-      th->context.ContextFlags = 0;
-    }
   add_thread (pid_to_ptid (id));
   /* Set the debug registers for the new thread in they are used.  */
   if (debug_registers_used)
@@ -1740,16 +1717,6 @@ child_resume (ptid_t ptid, int step, enu
   th = thread_rec (current_event.dwThreadId, FALSE);
   if (th)
     {
-      if (debug_registers_changed)
-        {
-          th->context.Dr0 = dr[0];
-          th->context.Dr1 = dr[1];
-          th->context.Dr2 = dr[2];
-          th->context.Dr3 = dr[3];
-          /* th->context.Dr6 = dr[6];
-           FIXME: should we set dr6 also ?? */
-          th->context.Dr7 = dr[7];
-        }
       if (step)
 	{
 	  /* Single step by setting t bit */
