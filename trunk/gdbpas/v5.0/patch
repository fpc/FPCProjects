diff -urN origdb/Makefile.in gdb/Makefile.in
--- origdb/Makefile.in	Thu May 18 05:44:54 2000
+++ gdb/Makefile.in	Thu Nov  2 17:46:00 2000
@@ -473,8 +473,10 @@
 	ui-out.c cli-out.c \
 	varobj.c wrapper.c \
 	jv-exp.y jv-lang.c jv-valprint.c jv-typeprint.c \
+	p-exp.y p-lang.c p-valprint.c p-typeprint.c \
 	m2-exp.y m2-lang.c m2-typeprint.c m2-valprint.c main.c maint.c \
-	mem-break.c minsyms.c mipsread.c nlmread.c objfiles.c parse.c \
+	mem-break.c minsyms.c mipsread.c nlmread.c objfiles.c \
+	p-exp.y p-lang.c p-typeprint.c p-valprint.c parse.c \
 	printcmd.c remote.c remote-nrom.c scm-exp.c scm-lang.c \
 	scm-valprint.c source.c stabsread.c stack.c symfile.c \
 	symmisc.c symtab.c target.c thread.c top.c tracepoint.c \
@@ -563,7 +565,7 @@
 	symfile.h stabsread.h target.h terminal.h typeprint.h xcoffsolib.h \
 	c-lang.h ch-lang.h f-lang.h \
 	jv-lang.h \
-	m2-lang.h \
+	m2-lang.h  p-lang.h \
 	complaints.h valprint.h \
 	29k-share/udi/udiids.h 29k-share/udi_soc nindy-share/b.out.h \
 	nindy-share/block_io.h nindy-share/coff.h \
@@ -617,7 +619,7 @@
 	ui-out.o cli-out.o \
 	varobj.o wrapper.o \
 	jv-lang.o jv-valprint.o jv-typeprint.o \
-	m2-lang.o \
+ 	m2-lang.o p-lang.o p-typeprint.o p-valprint.o \
 	scm-exp.o scm-lang.o scm-valprint.o complaints.o typeprint.o \
 	c-typeprint.o ch-typeprint.o f-typeprint.o m2-typeprint.o \
 	c-valprint.o cp-valprint.o ch-valprint.o f-valprint.o m2-valprint.o \
@@ -637,10 +639,10 @@
 # For now, shortcut the "configure GDB for fewer languages" stuff.
 YYFILES = c-exp.tab.c \
 	jv-exp.tab.c \
-	f-exp.tab.c m2-exp.tab.c
+	f-exp.tab.c m2-exp.tab.c p-exp.tab.c
 YYOBJ = c-exp.tab.o \
 	jv-exp.tab.o \
-	f-exp.tab.o m2-exp.tab.o
+	f-exp.tab.o m2-exp.tab.o p-exp.tab.o

 # Things which need to be built when making a distribution.

@@ -651,7 +653,7 @@
 .c.o:
 	$(CC) -c $(INTERNAL_CFLAGS) $<

-all: gdb$(EXEEXT) $(CONFIG_ALL)
+all: gdbpas$(EXEEXT) $(CONFIG_ALL)
 	@$(MAKE) $(FLAGS_TO_PASS) DO=all "DODIRS=`echo $(SUBDIRS) | sed 's/testsuite//'`" subdir_do

 installcheck:
@@ -689,7 +691,7 @@
 		  true ; \
 		fi ; \
 		$(srcdir)/../mkinstalldirs $(bindir) ; \
-		$(INSTALL_PROGRAM) gdb$(EXEEXT) $(bindir)/$$transformed_name$(EXEEXT) ; \
+		$(INSTALL_PROGRAM) gdbpas$(EXEEXT) $(bindir)/$$transformed_name$(EXEEXT) ; \
 		$(srcdir)/../mkinstalldirs $(man1dir) ; \
 		$(INSTALL_DATA) $(srcdir)/gdb.1 $(man1dir)/$$transformed_name.1
 	@$(MAKE) DO=install "DODIRS=$(SUBDIRS)" $(FLAGS_TO_PASS) subdir_do
@@ -765,9 +767,9 @@
 init.o: init.c $(defs_h) $(call_cmds_h)

 # Removing the old gdb first works better if it is running, at least on SunOS.
-gdb$(EXEEXT): main.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
-	rm -f gdb$(EXEEXT)
-	$(HLDENV) $(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) -o gdb$(EXEEXT) main.o libgdb.a $(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+gdbpas$(EXEEXT): main.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+	rm -f gdbpas$(EXEEXT)
+	$(HLDENV) $(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) -o gdbpas$(EXEEXT) main.o libgdb.a $(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)

 nlm:	force
 	rootme=`pwd`; export rootme; $(MAKE) $(TARGET_FLAGS_TO_PASS) DO=all DODIRS=nlm subdir_do
@@ -816,9 +818,9 @@
 # gdb and put a copy in gdb1, and you can run it with "gdb gdb1".
 # Removing gdb1 before the copy is the right thing if gdb1 is open
 # in another process.
-gdb1$(EXEEXT): gdb$(EXEEXT)
-	rm -f gdb1$(EXEEXT)
-	cp gdb$(EXEEXT) gdb1$(EXEEXT)
+gdbpas1$(EXEEXT): gdbpas$(EXEEXT)
+	rm -f gdbpas1$(EXEEXT)
+	cp gdbpas$(EXEEXT) gdbpas1$(EXEEXT)

 # FIXME. These are not generated by "make depend" because they only are there
 # for some machines.
@@ -870,7 +872,7 @@
 	@$(MAKE) $(FLAGS_TO_PASS) DO=clean "DODIRS=$(SUBDIRS)" subdir_do
 	rm -f *.o *.a $(ADD_FILES) *~ init.c-tmp init.l-tmp
 	rm -f init.c version.c
-	rm -f gdb$(EXEEXT) core make.log
+	rm -f gdbpas$(EXEEXT) core make.log
 	rm -f gdb[0-9]$(EXEEXT)

 # This used to depend on c-exp.tab.c m2-exp.tab.c TAGS
@@ -893,7 +895,7 @@
 	@echo "it deletes files that may require special tools to rebuild."
 	rm -f c-exp.tab.c \
 		jv-exp.tab \
-		f-exp.tab.c m2-exp.tab.c
+		f-exp.tab.c m2-exp.tab.c p-exp.tab.c
 	rm -f TAGS $(INFOFILES)
 	rm -f $(YYFILES)
 	rm -f nm.h tm.h xm.h config.status
@@ -1027,9 +1029,27 @@
 	-rm m2-exp.tmp
 	mv m2-exp.new ./m2-exp.tab.c

+# p-exp.tab.c is generated in objdir from p-exp.y if it doesn't exist
+# in srcdir, then compiled in objdir to p-exp.tab.o.
+# Remove bogus decls for malloc/realloc/free which conflict with everything
+# else.
+p-exp.tab.o: p-exp.tab.c
+p-exp.tab.c: p-exp.y
+	$(SHELL) $(YLWRAP) "$(YACC)" $(srcdir)/p-exp.y  y.tab.c p-exp.tmp -- $(YFLAGS)
+	-sed -e '/extern.*malloc/d' \
+	     -e '/extern.*realloc/d' \
+	     -e '/extern.*free/d' \
+	     -e '/include.*malloc.h/d' \
+	     -e 's/malloc/xmalloc/g' \
+	     -e 's/realloc/xrealloc/g' \
+	     -e '/^#line.*y.tab.c/d' \
+	  < p-exp.tmp > p-exp.new
+	-rm p-exp.tmp
+	mv p-exp.new ./p-exp.tab.c
+
 # These files are updated atomically, so make never has to remove them
 .PRECIOUS: m2-exp.tab.c f-exp.tab.c c-exp.tab.c
-.PRECIOUS: jv-exp.tab.c
+.PRECIOUS: jv-exp.tab.c p-exp.tab.c

 lint: $(LINTFILES)
 	$(LINT) $(INCLUDE_CFLAGS) $(LINTFLAGS) $(LINTFILES) \
@@ -1425,6 +1445,9 @@
 i387-tdep.o: i387-tdep.c $(floatformat_h) $(defs_h) $(gdbcore_h) \
 	$(inferior_h) language.h

+go32-nat.o: go32-nat.c
+	$(CC) -c $(INTERNAL_CFLAGS) -D __NEW_DBGCOM__ go32-nat.c
+
 i960-tdep.o: i960-tdep.c $(floatformat_h) $(defs_h) $(expression_h) \
 	$(frame_h) $(gdbtypes_h) $(symtab_h) $(value_h) $(gdbcore_h)

@@ -1493,6 +1516,16 @@
 m3-nat.o: m3-nat.c $(defs_h) $(inferior_h) $(value_h) language.h target.h \
 	gdb_wait.h $(gdbcmd_h) $(gdbcore_h)

+p-lang.o: p-lang.c p-lang.h $(defs_h) $(expression_h) $(gdbtypes_h) \
+	language.h parser-defs.h $(symtab_h) gdb_string.h
+
+p-typeprint.o: p-typeprint.c p-lang.h $(defs_h) $(expression_h) \
+	$(gdbcmd_h) $(gdbcore_h) $(gdbtypes_h) language.h $(symtab_h) \
+	target.h typeprint.h $(value_h) gdb_string.h
+
+p-valprint.o: p-valprint.c $(defs_h) $(expression_h) $(gdbtypes_h) \
+	language.h $(symtab_h) valprint.h $(value_h) gdb_string.h
+
 m68k-tdep.o: m68k-tdep.c $(defs_h) $(frame_h) $(symtab_h) $(value_h) \
 	$(gdbcore_h) gdb_string.h

@@ -1936,6 +1969,10 @@

 m2-exp.tab.o: m2-exp.tab.c $(defs_h) $(expression_h) $(gdbtypes_h) \
 	language.h m2-lang.h parser-defs.h $(symtab_h) $(value_h) \
+	$(bfd_h) objfiles.h symfile.h
+
+p-exp.tab.o: p-exp.tab.c $(defs_h) $(expression_h) $(gdbtypes_h) \
+	language.h p-lang.h parser-defs.h $(symtab_h) $(value_h) \
 	$(bfd_h) objfiles.h symfile.h

 gdb-events.o: gdb-events.c gdb-events.h $(defs_h) $(gdbcmd_h)
diff -urN origdb/c-lang.c gdb/c-lang.c
--- origdb/c-lang.c	Tue Feb  8 05:39:00 2000
+++ gdb/c-lang.c	Thu Nov  2 12:40:58 2000
@@ -28,7 +28,7 @@
 #include "valprint.h"

 extern void _initialize_c_language PARAMS ((void));
-static void c_emit_char (int c, struct ui_file * stream, int quoter);
+static void c_emit_char (int c, struct ui_file *stream, int quoter);

 /* Print the character C on STREAM as part of the contents of a literal
    string whose delimiter is QUOTER.  Note that that format for printing
diff -urN origdb/c-lang.h gdb/c-lang.h
--- origdb/c-lang.h	Wed Feb  2 01:21:04 2000
+++ gdb/c-lang.h	Thu Nov  2 12:40:58 2000
@@ -46,7 +46,7 @@

 extern void c_printchar (int, struct ui_file *);

-extern void c_printstr (struct ui_file * stream, char *string,
+extern void c_printstr (struct ui_file *stream, char *string,
 			unsigned int length, int width,
 			int force_ellipses);

diff -urN origdb/c-typeprint.c gdb/c-typeprint.c
--- origdb/c-typeprint.c	Sat Feb  5 08:29:40 2000
+++ gdb/c-typeprint.c	Thu Nov  2 12:40:58 2000
@@ -42,7 +42,7 @@
 /* Flag indicating target was compiled by HP compiler */
 extern int hp_som_som_object_present;

-static void cp_type_print_method_args (struct type ** args, char *prefix,
+static void cp_type_print_method_args (struct type **args, char *prefix,
 				       char *varstring, int staticp,
 				       struct ui_file *stream);

@@ -451,7 +451,7 @@
     return 0;

   name += 8;
-  if (! strchr (" \t\f\n\r", *name))
+  if (!strchr (" \t\f\n\r", *name))
     return 0;

   while (strchr (" \t\f\n\r", *name))
diff -urN origdb/defs.h gdb/defs.h
--- origdb/defs.h	Mon May  1 06:45:32 2000
+++ gdb/defs.h	Thu Nov  2 12:40:58 2000
@@ -203,7 +203,8 @@
     language_fortran,		/* Fortran */
     language_m2,		/* Modula-2 */
     language_asm,		/* Assembly language */
-    language_scm		/* Scheme / Guile */
+    language_scm,    /* Scheme / Guile */
+    language_pascal		/* Pascal FPC GNU ?? */
   };

 enum precision_type
diff -urN origdb/eval.c gdb/eval.c
--- origdb/eval.c	Tue Apr  4 05:53:48 2000
+++ gdb/eval.c	Thu Nov  2 12:40:58 2000
@@ -1208,6 +1208,7 @@

     case BINOP_MUL:
     case BINOP_DIV:
+    case BINOP_INTDIV:
     case BINOP_REM:
     case BINOP_MOD:
     case BINOP_LSH:
diff -urN origdb/gnu-regex.c gdb/gnu-regex.c
--- origdb/gnu-regex.c	Tue Mar 28 14:13:14 2000
+++ gdb/gnu-regex.c	Fri Dec  1 10:46:36 2000
@@ -1072,9 +1072,9 @@
 # if defined MATCH_MAY_ALLOCATE
 /* 4400 was enough to cause a crash on Alpha OSF/1,
    whose default stack limit is 2mb.  */
-long int re_max_failures = 4000;
+long int gdb_re_max_failures = 4000;
 # else
-long int re_max_failures = 2000;
+long int gdb_re_max_failures = 2000;
 # endif

 union fail_stack_elt
@@ -1097,9 +1097,9 @@
 # if defined MATCH_MAY_ALLOCATE
 /* 4400 was enough to cause a crash on Alpha OSF/1,
    whose default stack limit is 2mb.  */
-int re_max_failures = 20000;
+int gdb_re_max_failures = 20000;
 # else
-int re_max_failures = 2000;
+int gdb_re_max_failures = 2000;
 # endif

 union fail_stack_elt
@@ -1151,7 +1151,7 @@
 #endif


-/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
+/* Double the size of FAIL_STACK, up to approximately `gdb_re_max_failures' items.

    Return 1 if succeeds, and 0 if either ran out of memory
    allocating space for it or it was already too large.
@@ -1159,7 +1159,7 @@
    REGEX_REALLOCATE_STACK requires `destination' be declared.   */

 #define DOUBLE_FAIL_STACK(fail_stack)					\
-  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
+  ((fail_stack).size > (unsigned) (gdb_re_max_failures * MAX_FAILURE_ITEMS)	\
    ? 0									\
    : ((fail_stack).stack = (fail_stack_elt_t *)				\
         REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
@@ -2880,11 +2880,11 @@
     int num_regs = bufp->re_nsub + 1;

     /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
-       is strictly greater than re_max_failures, the largest possible stack
-       is 2 * re_max_failures failure points.  */
-    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
+       is strictly greater than gdb_re_max_failures, the largest possible stack
+       is 2 * gdb_re_max_failures failure points.  */
+    if (fail_stack.size < (2 * gdb_re_max_failures * MAX_FAILURE_ITEMS))
       {
-	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
+	fail_stack.size = (2 * gdb_re_max_failures * MAX_FAILURE_ITEMS);

 # ifdef emacs
 	if (! fail_stack.stack)
@@ -5480,6 +5480,7 @@

 /* BSD has one and only one pattern buffer.  */
 static struct re_pattern_buffer re_comp_buf;
+static RE_TRANSLATE_TYPE case_insensitive_buffer;

 char *
 #ifdef _LIBC
@@ -5538,6 +5539,78 @@
   const int len = strlen (s);
   return
     0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
+}
+
+/* allocates a unique translation buffer for insensitive search */
+/* FIXME this buffer is never disposed */
+
+int create_case_insensitive_translate_buffer ()
+{
+  int i;
+      if (!case_insensitive_buffer)
+   {
+    case_insensitive_buffer = (RE_TRANSLATE_TYPE) malloc (CHAR_SET_SIZE
+				      * sizeof (*(RE_TRANSLATE_TYPE)0));
+    if (case_insensitive_buffer == NULL)
+      return (int) REG_ESPACE;
+
+    /* Map uppercase characters to corresponding lowercase ones.  */
+    for (i = 0; i < CHAR_SET_SIZE; i++)
+      case_insensitive_buffer[i] = ISLOWER (i) ? toupper (i) : i;
+   }
+
+  /* Use this for re_comp called after */
+  re_comp_buf.translate = case_insensitive_buffer;
+
+  return 0;
+}
+
+int reset_translate_buffer ()
+{
+  int i;
+  if (case_insensitive_buffer)
+    free(case_insensitive_buffer);
+  /* Use this for re_comp called after */
+  re_comp_buf.translate = NULL;
+  return 0;
+}
+
+int
+re_iexec (s,insensitive)
+    char *s;
+    int insensitive;
+{
+  RE_TRANSLATE_TYPE store_translate;
+  struct re_pattern_buffer  private_preg;
+  const int len = strlen (s);
+  int res;
+  if (insensitive)
+    {
+      unsigned i;
+      if (!case_insensitive_buffer)
+        {
+          int res = create_case_insensitive_translate_buffer();
+          if (res)
+            return res;
+        }
+      store_translate = re_comp_buf.translate;
+      re_comp_buf.translate = case_insensitive_buffer;
+
+      for (i = 0; i < len; i++)
+        if (ISLOWER(s[i]))
+          s[i] = toupper (s[i]);
+    }
+  else
+    {
+      store_translate = re_comp_buf.translate;
+      re_comp_buf.translate = case_insensitive_buffer;
+
+    }
+  res = re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
+
+  re_comp_buf.translate = store_translate;
+  return
+     0 <= res;
 }

 #endif /* _REGEX_RE_COMP */
--- origdb/gnu-regex.h  Tue Oct 12 05:37:20 1999
+++ gdb/gnu-regex.h	Thu Nov  2 12:41:00 2000
@@ -536,8 +536,12 @@
 #ifdef _REGEX_RE_COMP
 # ifndef _CRAY
 /* 4.2 bsd compatibility.  */
+extern int create_case_insensitive_translate_buffer _RE_ARGS (());
+extern int reset_translate_buffer _RE_ARGS (());
 extern char *re_comp _RE_ARGS ((const char *));
 extern int re_exec _RE_ARGS ((const char *));
+extern int re_iexec _RE_ARGS ((char *,int));
+
 # endif
 #endif

diff -urN origdb/language.c gdb/language.c
--- origdb/language.c	Fri Mar 17 11:19:22 2000
+++ gdb/language.c	Thu Nov  2 12:41:00 2000
@@ -826,6 +826,7 @@
     {
     case language_c:
     case language_cplus:
+    case language_pascal:
       return (TYPE_CODE (type) != TYPE_CODE_INT) &&
 	(TYPE_CODE (type) != TYPE_CODE_ENUM) ? 0 : 1;
     case language_m2:
@@ -868,6 +869,7 @@

     case language_c:
     case language_cplus:
+    case language_pascal:
       return (TYPE_CODE (type) == TYPE_CODE_INT) &&
 	TYPE_LENGTH (type) == sizeof (char)
       ? 1 : 0;
@@ -886,6 +888,7 @@
     {
     case language_chill:
     case language_m2:
+    case language_pascal:
       return TYPE_CODE (type) != TYPE_CODE_STRING ? 0 : 1;

     case language_c:
@@ -909,6 +912,7 @@
     {
     case language_c:
     case language_cplus:
+    case language_pascal:
       /* Might be more cleanly handled by having a TYPE_CODE_INT_NOT_BOOL
          for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
       if (TYPE_CODE (type) == TYPE_CODE_INT)
@@ -950,6 +954,11 @@
       return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
 	(TYPE_CODE (type) == TYPE_CODE_UNION) ||
 	(TYPE_CODE (type) == TYPE_CODE_ARRAY);
+   case language_pascal:
+      return (TYPE_CODE(type) == TYPE_CODE_STRUCT) ||
+	 (TYPE_CODE(type) == TYPE_CODE_UNION) ||
+	 (TYPE_CODE(type) == TYPE_CODE_SET) ||
+	    (TYPE_CODE(type) == TYPE_CODE_ARRAY);
     case language_m2:
       return (TYPE_CODE (type) == TYPE_CODE_STRUCT) ||
 	(TYPE_CODE (type) == TYPE_CODE_SET) ||
@@ -981,7 +990,11 @@
 	}
       return builtin_type_f_logical_s2;
     case language_cplus:
-      sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);
+    case language_pascal:
+      if (current_language->la_language==language_cplus)
+        {sym = lookup_symbol ("bool", NULL, VAR_NAMESPACE, NULL, NULL);}
+      else
+        {sym = lookup_symbol ("boolean", NULL, VAR_NAMESPACE, NULL, NULL);}
       if (sym)
 	{
 	  type = SYMBOL_TYPE (sym);
@@ -1173,6 +1186,21 @@
 		type_op_error ("Arguments to %s must be of integral type.", op);
 	      break;
 	    }
+#endif
+
+#ifdef _LANG_pascal
+      case language_pascal:
+	 switch(op)
+	 {
+	 case BINOP_DIV:
+	    if (!float_type(t1) || !float_type(t2))
+	       type_op_error ("Arguments to %s must be floating point numbers.",op);
+	    break;
+	 case BINOP_INTDIV:
+	    if (!integral_type(t1) || !integral_type(t2))
+	       type_op_error ("Arguments to %s must be of integral type.",op);
+	    break;
+	 }
 #endif

 #ifdef _LANG_chill
diff -urN origdb/language.h gdb/language.h
--- origdb/language.h	Sat Mar  4 05:56:46 2000
+++ gdb/language.h	Thu Nov  2 12:41:00 2000
@@ -36,6 +36,7 @@
 #define	_LANG_m2
 #define	_LANG_chill
 #define _LANG_fortran
+#define _LANG_pascal

 #define MAX_FORTRAN_DIMS  7	/* Maximum number of F77 array dims */

diff -urN origdb/maint.c gdb/maint.c
--- origdb/maint.c	Wed Apr 19 08:59:20 2000
+++ gdb/maint.c	Thu Nov  2 12:41:00 2000
@@ -105,8 +105,8 @@
       kill (getpid (), SIGABRT);
 #else
       signal (SIGQUIT, SIG_DFL);
-      kill (getpid (), SIGQUIT);
 #endif
+      kill (getpid (), SIGQUIT);
     }
 }
 #endif
diff -urN origdb/p-exp.tab.c gdb/p-exp.tab.c
--- origdb/p-exp.tab.c	Thu Jan  1 00:00:00 1970
+++ gdb/p-exp.tab.c	Fri Nov  3 11:29:26 2000
@@ -0,0 +1,2285 @@
+
+/*  A Bison parser, made from p-exp.y
+ by  GNU Bison version 1.25
+  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define	INT	258
+#define	FLOAT	259
+#define	STRING	260
+#define	NAME	261
+#define	TYPENAME	262
+#define	NAME_OR_INT	263
+#define	STRUCT	264
+#define	CLASS	265
+#define	SIZEOF	266
+#define	COLONCOLON	267
+#define	ERROR	268
+#define	VARIABLE	269
+#define	THIS	270
+#define	TRUE	271
+#define	FALSE	272
+#define	ABOVE_COMMA	273
+#define	ASSIGN	274
+#define	NOT	275
+#define	OR	276
+#define	XOR	277
+#define	ANDAND	278
+#define	NOTEQUAL	279
+#define	LEQ	280
+#define	GEQ	281
+#define	LSH	282
+#define	RSH	283
+#define	DIV	284
+#define	MOD	285
+#define	UNARY	286
+#define	INCREMENT	287
+#define	DECREMENT	288
+#define	ARROW	289
+#define	BLOCKNAME	290
+
+#line 47 "p-exp.y"
+
+
+#include "defs.h"
+#include "gdb_string.h"
+#include <ctype.h>
+#include "expression.h"
+#include "value.h"
+#include "parser-defs.h"
+#include "language.h"
+#include "p-lang.h"
+#include "bfd.h" /* Required by objfiles.h.  */
+#include "symfile.h" /* Required by objfiles.h.  */
+#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
+
+/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
+   as well as gratuitiously global symbol names, so we can have multiple
+   yacc generated parsers in gdb.  Note that these are only the variables
+   produced by yacc.  If other parser generators (bison, byacc, etc) produce
+   additional global names that conflict at link time, then those parser
+   generators need to be fixed instead of adding those names to this list. */
+
+#define	yymaxdepth pascal_maxdepth
+#define	yyparse	pascal_parse
+#define	yylex	pascal_lex
+#define	yyerror	pascal_error
+#define	yylval	pascal_lval
+#define	yychar	pascal_char
+#define	yydebug	pascal_debug
+#define	yypact	pascal_pact	
+#define	yyr1	pascal_r1			
+#define	yyr2	pascal_r2			
+#define	yydef	pascal_def		
+#define	yychk	pascal_chk		
+#define	yypgo	pascal_pgo		
+#define	yyact	pascal_act
+#define	yyexca	pascal_exca
+#define yyerrflag pascal_errflag
+#define yynerrs	pascal_nerrs
+#define	yyps	pascal_ps
+#define	yypv	pascal_pv
+#define	yys	pascal_s
+#define	yy_yys	pascal_yys
+#define	yystate	pascal_state
+#define	yytmp	pascal_tmp
+#define	yyv	pascal_v
+#define	yy_yyv	pascal_yyv
+#define	yyval	pascal_val
+#define	yylloc	pascal_lloc
+#define yyreds	pascal_reds		/* With YYDEBUG defined */
+#define yytoks	pascal_toks		/* With YYDEBUG defined */
+#define yylhs	pascal_yylhs
+#define yylen	pascal_yylen
+#define yydefred pascal_yydefred
+#define yydgoto	pascal_yydgoto
+#define yysindex pascal_yysindex
+#define yyrindex pascal_yyrindex
+#define yygindex pascal_yygindex
+#define yytable	 pascal_yytable
+#define yycheck	 pascal_yycheck
+
+#ifndef YYDEBUG
+#define	YYDEBUG	0		/* Default to no yydebug support */
+#endif
+
+int yyparse (void);
+
+static int yylex (void);
+
+void
+yyerror (char *);
+
+static char * uptok (char *, int);
+
+#line 125 "p-exp.y"
+typedef union
+  {
+    LONGEST lval;
+    struct {
+      LONGEST val;
+      struct type *type;
+    } typed_val_int;
+    struct {
+      DOUBLEST dval;
+      struct type *type;
+    } typed_val_float;
+    struct symbol *sym;
+    struct type *tval;
+    struct stoken sval;
+    struct ttype tsym;
+    struct symtoken ssym;
+    int voidval;
+    struct block *bval;
+    enum exp_opcode opcode;
+    struct internalvar *ivar;
+
+    struct type **tvec;
+    int *ivec;
+  } YYSTYPE;
+#line 150 "p-exp.y"
+
+/* YYSTYPE gets defined by %union */
+static int
+parse_number (char *, int, int, YYSTYPE *);
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		117
+#define	YYFLAG		-32768
+#define	YYNTBASE	51
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 290 ? yytranslate[x] : 65)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,    46,
+    49,    38,    36,    18,    37,    44,    39,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,    27,
+    25,    28,     2,    35,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+    45,     2,    50,    48,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+    16,    17,    19,    20,    21,    22,    23,    24,    26,    29,
+    30,    31,    32,    33,    34,    40,    41,    42,    43,    47
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     2,     4,     6,     8,    12,    15,    18,    21,    24,
+    29,    34,    38,    43,    44,    50,    51,    53,    57,    62,
+    66,    70,    74,    78,    82,    86,    90,    94,    98,   102,
+   106,   110,   114,   118,   122,   126,   130,   134,   138,   140,
+   142,   144,   146,   148,   150,   152,   157,   159,   161,   163,
+   167,   171,   175,   177,   180,   182,   184,   186,   190,   192,
+   195,   198,   200,   202,   204,   206,   208
+};
+
+static const short yyrhs[] = {    53,
+     0,    52,     0,    61,     0,    54,     0,    53,    18,    54,
+     0,    54,    48,     0,    35,    54,     0,    37,    54,     0,
+    21,    54,     0,    41,    46,    54,    49,     0,    42,    46,
+    54,    49,     0,    54,    44,    63,     0,    54,    45,    53,
+    50,     0,     0,    54,    46,    55,    56,    49,     0,     0,
+    54,     0,    56,    18,    54,     0,    61,    46,    54,    49,
+     0,    46,    53,    49,     0,    54,    38,    54,     0,    54,
+    39,    54,     0,    54,    33,    54,     0,    54,    34,    54,
+     0,    54,    36,    54,     0,    54,    37,    54,     0,    54,
+    31,    54,     0,    54,    32,    54,     0,    54,    25,    54,
+     0,    54,    26,    54,     0,    54,    29,    54,     0,    54,
+    30,    54,     0,    54,    27,    54,     0,    54,    28,    54,
+     0,    54,    24,    54,     0,    54,    23,    54,     0,    54,
+    22,    54,     0,    54,    20,    54,     0,    16,     0,    17,
+     0,     3,     0,     8,     0,     4,     0,    58,     0,    14,
+     0,    11,    46,    61,    49,     0,     5,     0,    15,     0,
+    47,     0,    57,    12,    63,     0,    57,    12,    63,     0,
+    62,    12,    63,     0,    59,     0,    12,    63,     0,    64,
+     0,    62,     0,    60,     0,    62,    12,    38,     0,     7,
+     0,     9,    63,     0,    10,    63,     0,     6,     0,    47,
+     0,     7,     0,     8,     0,     6,     0,    47,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   222,   223,   226,   233,   234,   239,   242,   245,   249,   253,
+   257,   261,   267,   271,   275,   281,   282,   284,   288,   294,
+   300,   304,   308,   312,   316,   320,   324,   328,   332,   336,
+   340,   344,   348,   352,   356,   360,   364,   368,   372,   378,
+   384,   391,   402,   409,   412,   416,   424,   449,   456,   473,
+   484,   500,   515,   516,   550,   608,   619,   620,   625,   627,
+   630,   638,   639,   640,   641,   644,   645
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","INT","FLOAT",
+"STRING","NAME","TYPENAME","NAME_OR_INT","STRUCT","CLASS","SIZEOF","COLONCOLON",
+"ERROR","VARIABLE","THIS","TRUE","FALSE","','","ABOVE_COMMA","ASSIGN","NOT",
+"OR","XOR","ANDAND","'='","NOTEQUAL","'<'","'>'","LEQ","GEQ","LSH","RSH","DIV",
+"MOD","'@'","'+'","'-'","'*'","'/'","UNARY","INCREMENT","DECREMENT","ARROW",
+"'.'","'['","'('","BLOCKNAME","'^'","')'","']'","start","type_exp","exp1","exp",
+"@1","arglist","block","variable","qualified_name","ptype","type","typebase",
+"name","name_not_typename", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+    51,    51,    52,    53,    53,    54,    54,    54,    54,    54,
+    54,    54,    54,    55,    54,    56,    56,    56,    54,    54,
+    54,    54,    54,    54,    54,    54,    54,    54,    54,    54,
+    54,    54,    54,    54,    54,    54,    54,    54,    54,    54,
+    54,    54,    54,    54,    54,    54,    54,    54,    57,    57,
+    58,    59,    58,    58,    58,    60,    61,    61,    62,    62,
+    62,    63,    63,    63,    63,    64,    64
+};
+
+static const short yyr2[] = {     0,
+     1,     1,     1,     1,     3,     2,     2,     2,     2,     4,
+     4,     3,     4,     0,     5,     0,     1,     3,     4,     3,
+     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+     3,     3,     3,     3,     3,     3,     3,     3,     1,     1,
+     1,     1,     1,     1,     1,     4,     1,     1,     1,     3,
+     3,     3,     1,     2,     1,     1,     1,     3,     1,     2,
+     2,     1,     1,     1,     1,     1,     1
+};
+
+static const short yydefact[] = {     0,
+    41,    43,    47,    66,    59,    42,     0,     0,     0,     0,
+    45,    48,    39,    40,     0,     0,     0,     0,     0,     0,
+    67,     2,     1,     4,     0,    44,    53,    57,     3,    56,
+    55,    62,    64,    65,    63,    60,    61,     0,    54,     9,
+     0,     7,     8,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,     0,     0,    14,     6,     0,
+     0,     0,     0,    56,     0,     0,    20,     5,    38,    37,
+    36,    35,    29,    30,    33,    34,    31,    32,    27,    28,
+    23,    24,    25,    26,    21,    22,    12,     0,    16,    51,
+     0,    58,    52,    46,     0,    10,    11,    13,    17,     0,
+    19,     0,    15,    18,     0,     0,     0
+};
+
+static const short yydefgoto[] = {   115,
+    22,    23,    24,    99,   110,    25,    26,    27,    28,    41,
+    30,    36,    31
+};
+
+static const short yypact[] = {    65,
+-32768,-32768,-32768,-32768,-32768,-32768,     5,     5,   -37,     5,
+-32768,-32768,-32768,-32768,    65,    65,    65,   -32,   -27,    65,
+    14,-32768,     2,   183,    19,-32768,-32768,-32768,   -18,    47,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,     8,-32768,   -38,
+   -18,   -38,   -38,    65,    65,     6,    65,    65,    65,    65,
+    65,    65,    65,    65,    65,    65,    65,    65,    65,    65,
+    65,    65,    65,    65,    65,     5,    65,-32768,-32768,     5,
+    65,    15,    11,    51,    93,   123,-32768,   183,   183,   209,
+   234,   258,   280,   280,   298,   298,   298,   298,   311,   311,
+   311,   311,    50,    50,   -38,   -38,-32768,     7,    65,    52,
+   153,-32768,-32768,-32768,    28,-32768,-32768,-32768,   183,     9,
+-32768,    65,-32768,   183,    78,    83,-32768
+};
+
+static const short yypgoto[] = {-32768,
+-32768,   -16,   -15,-32768,-32768,-32768,-32768,-32768,-32768,    16,
+    49,    -5,-32768
+};
+
+
+#define	YYLAST		359
+
+
+static const short yytable[] = {    40,
+    42,    43,    37,    46,    39,    66,    67,    68,    38,    69,
+    32,    33,    34,    44,     5,    29,     7,     8,    45,    47,
+    32,    33,    34,    47,    47,   -49,   112,    71,    75,    76,
+    70,    78,    79,    80,    81,    82,    83,    84,    85,    86,
+    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+    98,    35,   102,    73,    77,   101,   108,   113,    72,   104,
+    97,    35,   105,   -50,   100,   102,   103,     1,     2,     3,
+     4,     5,     6,     7,     8,     9,    10,   116,    11,    12,
+    13,    14,   117,   109,     0,    15,    74,    64,    65,     0,
+     0,     0,     0,    66,    67,    68,   114,    69,     0,    16,
+     0,    17,     0,     0,     0,    18,    19,     0,     0,     0,
+    20,    21,    48,     0,    49,    50,    51,    52,    53,    54,
+    55,    56,    57,    58,    59,    60,    61,     0,    62,    63,
+    64,    65,     0,     0,     0,     0,    66,    67,    68,     0,
+    69,   106,    48,     0,    49,    50,    51,    52,    53,    54,
+    55,    56,    57,    58,    59,    60,    61,     0,    62,    63,
+    64,    65,     0,     0,     0,     0,    66,    67,    68,     0,
+    69,   107,    48,     0,    49,    50,    51,    52,    53,    54,
+    55,    56,    57,    58,    59,    60,    61,     0,    62,    63,
+    64,    65,     0,     0,     0,     0,    66,    67,    68,     0,
+    69,   111,    48,     0,    49,    50,    51,    52,    53,    54,
+    55,    56,    57,    58,    59,    60,    61,     0,    62,    63,
+    64,    65,     0,     0,     0,     0,    66,    67,    68,     0,
+    69,    50,    51,    52,    53,    54,    55,    56,    57,    58,
+    59,    60,    61,     0,    62,    63,    64,    65,     0,     0,
+     0,     0,    66,    67,    68,     0,    69,    51,    52,    53,
+    54,    55,    56,    57,    58,    59,    60,    61,     0,    62,
+    63,    64,    65,     0,     0,     0,     0,    66,    67,    68,
+     0,    69,    52,    53,    54,    55,    56,    57,    58,    59,
+    60,    61,     0,    62,    63,    64,    65,     0,     0,     0,
+     0,    66,    67,    68,     0,    69,    54,    55,    56,    57,
+    58,    59,    60,    61,     0,    62,    63,    64,    65,     0,
+     0,     0,     0,    66,    67,    68,     0,    69,    58,    59,
+    60,    61,     0,    62,    63,    64,    65,     0,     0,     0,
+     0,    66,    67,    68,     0,    69,    62,    63,    64,    65,
+     0,     0,     0,     0,    66,    67,    68,     0,    69
+};
+
+static const short yycheck[] = {    15,
+    16,    17,     8,    20,    10,    44,    45,    46,    46,    48,
+     6,     7,     8,    46,     7,     0,     9,    10,    46,    18,
+     6,     7,     8,    18,    18,    12,    18,    46,    44,    45,
+    12,    47,    48,    49,    50,    51,    52,    53,    54,    55,
+    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
+    67,    47,    38,    38,    49,    71,    50,    49,    12,    49,
+    66,    47,    12,    12,    70,    38,    72,     3,     4,     5,
+     6,     7,     8,     9,    10,    11,    12,     0,    14,    15,
+    16,    17,     0,    99,    -1,    21,    38,    38,    39,    -1,
+    -1,    -1,    -1,    44,    45,    46,   112,    48,    -1,    35,
+    -1,    37,    -1,    -1,    -1,    41,    42,    -1,    -1,    -1,
+    46,    47,    20,    -1,    22,    23,    24,    25,    26,    27,
+    28,    29,    30,    31,    32,    33,    34,    -1,    36,    37,
+    38,    39,    -1,    -1,    -1,    -1,    44,    45,    46,    -1,
+    48,    49,    20,    -1,    22,    23,    24,    25,    26,    27,
+    28,    29,    30,    31,    32,    33,    34,    -1,    36,    37,
+    38,    39,    -1,    -1,    -1,    -1,    44,    45,    46,    -1,
+    48,    49,    20,    -1,    22,    23,    24,    25,    26,    27,
+    28,    29,    30,    31,    32,    33,    34,    -1,    36,    37,
+    38,    39,    -1,    -1,    -1,    -1,    44,    45,    46,    -1,
+    48,    49,    20,    -1,    22,    23,    24,    25,    26,    27,
+    28,    29,    30,    31,    32,    33,    34,    -1,    36,    37,
+    38,    39,    -1,    -1,    -1,    -1,    44,    45,    46,    -1,
+    48,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+    32,    33,    34,    -1,    36,    37,    38,    39,    -1,    -1,
+    -1,    -1,    44,    45,    46,    -1,    48,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    -1,    36,
+    37,    38,    39,    -1,    -1,    -1,    -1,    44,    45,    46,
+    -1,    48,    25,    26,    27,    28,    29,    30,    31,    32,
+    33,    34,    -1,    36,    37,    38,    39,    -1,    -1,    -1,
+    -1,    44,    45,    46,    -1,    48,    27,    28,    29,    30,
+    31,    32,    33,    34,    -1,    36,    37,    38,    39,    -1,
+    -1,    -1,    -1,    44,    45,    46,    -1,    48,    31,    32,
+    33,    34,    -1,    36,    37,    38,    39,    -1,    -1,    -1,
+    -1,    44,    45,    46,    -1,    48,    36,    37,    38,    39,
+    -1,    -1,    -1,    -1,    44,    45,    46,    -1,    48
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/share/bison.simple"
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+#ifndef alloca
+#ifdef __GNUC__
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
+#include <alloca.h>
+#else /* not sparc */
+#if defined (MSDOS) && !defined (__TURBOC__)
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+ #pragma alloca
+#else /* not MSDOS, __TURBOC__, or _AIX */
+#ifdef __hpux
+#ifdef __cplusplus
+extern "C" {
+void *alloca (unsigned int);
+};
+#else /* not __cplusplus */
+void *alloca ();
+#endif /* not __cplusplus */
+#endif /* __hpux */
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc.  */
+#endif /* not GNU C.  */
+#endif /* alloca not defined.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	return(0)
+#define YYABORT 	return(1)
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+int yyparse (void);
+#endif
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, int count)
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 196 "/usr/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to xreallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to xreallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 3:
+#line 227 "p-exp.y"
+{ write_exp_elt_opcode(OP_TYPE);
+			  write_exp_elt_type(yyvsp[0].tval);
+			  write_exp_elt_opcode(OP_TYPE);;
+    break;}
+case 5:
+#line 235 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_COMMA); ;
+    break;}
+case 6:
+#line 240 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_IND); ;
+    break;}
+case 7:
+#line 243 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_ADDR); ;
+    break;}
+case 8:
+#line 246 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_NEG); ;
+    break;}
+case 9:
+#line 250 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); ;
+    break;}
+case 10:
+#line 254 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_PREINCREMENT); ;
+    break;}
+case 11:
+#line 258 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_PREDECREMENT); ;
+    break;}
+case 12:
+#line 262 "p-exp.y"
+{ write_exp_elt_opcode (STRUCTOP_STRUCT);
+			  write_exp_string (yyvsp[0].sval);
+			  write_exp_elt_opcode (STRUCTOP_STRUCT); ;
+    break;}
+case 13:
+#line 268 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_SUBSCRIPT); ;
+    break;}
+case 14:
+#line 274 "p-exp.y"
+{ start_arglist (); ;
+    break;}
+case 15:
+#line 276 "p-exp.y"
+{ write_exp_elt_opcode (OP_FUNCALL);
+			  write_exp_elt_longcst ((LONGEST) end_arglist ());
+			  write_exp_elt_opcode (OP_FUNCALL); ;
+    break;}
+case 17:
+#line 283 "p-exp.y"
+{ arglist_len = 1; ;
+    break;}
+case 18:
+#line 285 "p-exp.y"
+{ arglist_len++; ;
+    break;}
+case 19:
+#line 289 "p-exp.y"
+{ write_exp_elt_opcode (UNOP_CAST);
+			  write_exp_elt_type (yyvsp[-3].tval);
+			  write_exp_elt_opcode (UNOP_CAST); ;
+    break;}
+case 20:
+#line 295 "p-exp.y"
+{ ;
+    break;}
+case 21:
+#line 301 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_MUL); ;
+    break;}
+case 22:
+#line 305 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_DIV); ;
+    break;}
+case 23:
+#line 309 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_INTDIV); ;
+    break;}
+case 24:
+#line 313 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_REM); ;
+    break;}
+case 25:
+#line 317 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_ADD); ;
+    break;}
+case 26:
+#line 321 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_SUB); ;
+    break;}
+case 27:
+#line 325 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_LSH); ;
+    break;}
+case 28:
+#line 329 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_RSH); ;
+    break;}
+case 29:
+#line 333 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_EQUAL); ;
+    break;}
+case 30:
+#line 337 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_NOTEQUAL); ;
+    break;}
+case 31:
+#line 341 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_LEQ); ;
+    break;}
+case 32:
+#line 345 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_GEQ); ;
+    break;}
+case 33:
+#line 349 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_LESS); ;
+    break;}
+case 34:
+#line 353 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_GTR); ;
+    break;}
+case 35:
+#line 357 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_BITWISE_AND); ;
+    break;}
+case 36:
+#line 361 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_BITWISE_XOR); ;
+    break;}
+case 37:
+#line 365 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_BITWISE_IOR); ;
+    break;}
+case 38:
+#line 369 "p-exp.y"
+{ write_exp_elt_opcode (BINOP_ASSIGN); ;
+    break;}
+case 39:
+#line 373 "p-exp.y"
+{ write_exp_elt_opcode (OP_BOOL);
+			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_opcode (OP_BOOL); ;
+    break;}
+case 40:
+#line 379 "p-exp.y"
+{ write_exp_elt_opcode (OP_BOOL);
+			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_opcode (OP_BOOL); ;
+    break;}
+case 41:
+#line 385 "p-exp.y"
+{ write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (yyvsp[0].typed_val_int.type);
+			  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val_int.val));
+			  write_exp_elt_opcode (OP_LONG); ;
+    break;}
+case 42:
+#line 392 "p-exp.y"
+{ YYSTYPE val;
+			  parse_number (yyvsp[0].ssym.stoken.ptr, yyvsp[0].ssym.stoken.length, 0, &val);
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (val.typed_val_int.type);
+			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
+			  write_exp_elt_opcode (OP_LONG);
+			;
+    break;}
+case 43:
+#line 403 "p-exp.y"
+{ write_exp_elt_opcode (OP_DOUBLE);
+			  write_exp_elt_type (yyvsp[0].typed_val_float.type);
+			  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+			  write_exp_elt_opcode (OP_DOUBLE); ;
+    break;}
+case 46:
+#line 417 "p-exp.y"
+{ write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (builtin_type_int);
+			  CHECK_TYPEDEF (yyvsp[-1].tval);
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  write_exp_elt_opcode (OP_LONG); ;
+    break;}
+case 47:
+#line 425 "p-exp.y"
+{ /* C strings are converted into array constants with
+			     an explicit null byte added at the end.  Thus
+			     the array upper bound is the string length.
+			     There is no such thing in C as a completely empty
+			     string. */
+			  char *sp = yyvsp[0].sval.ptr; int count = yyvsp[0].sval.length;
+			  while (count-- > 0)
+			    {
+			      write_exp_elt_opcode (OP_LONG);
+			      write_exp_elt_type (builtin_type_char);
+			      write_exp_elt_longcst ((LONGEST)(*sp++));
+			      write_exp_elt_opcode (OP_LONG);
+			    }
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (builtin_type_char);
+			  write_exp_elt_longcst ((LONGEST)'\0');
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_opcode (OP_ARRAY);
+			  write_exp_elt_longcst ((LONGEST) 0);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[0].sval.length));
+			  write_exp_elt_opcode (OP_ARRAY); ;
+    break;}
+case 48:
+#line 450 "p-exp.y"
+{ write_exp_elt_opcode (OP_THIS);
+			  write_exp_elt_opcode (OP_THIS); ;
+    break;}
+case 49:
+#line 457 "p-exp.y"
+{
+			  if (yyvsp[0].ssym.sym != 0)
+			      yyval.bval = SYMBOL_BLOCK_VALUE (yyvsp[0].ssym.sym);
+			  else
+			    {
+			      struct symtab *tem =
+				  lookup_symtab (copy_name (yyvsp[0].ssym.stoken));
+			      if (tem)
+				yyval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
+			      else
+				error ("No file or function \"%s\".",
+				       copy_name (yyvsp[0].ssym.stoken));
+			    }
+			;
+    break;}
+case 50:
+#line 474 "p-exp.y"
+{ struct symbol *tem
+			    = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+					     VAR_NAMESPACE, (int *) NULL,
+					     (struct symtab **) NULL);
+			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
+			    error ("No function \"%s\" in specified context.",
+				   copy_name (yyvsp[0].sval));
+			  yyval.bval = SYMBOL_BLOCK_VALUE (tem); ;
+    break;}
+case 51:
+#line 485 "p-exp.y"
+{ struct symbol *sym;
+			  sym = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+					       VAR_NAMESPACE, (int *) NULL,
+					       (struct symtab **) NULL);
+			  if (sym == 0)
+			    error ("No symbol \"%s\" in specified context.",
+				   copy_name (yyvsp[0].sval));
+
+			  write_exp_elt_opcode (OP_VAR_VALUE);
+			  /* block_found is set by lookup_symbol.  */
+			  write_exp_elt_block (block_found);
+			  write_exp_elt_sym (sym);
+			  write_exp_elt_opcode (OP_VAR_VALUE); ;
+    break;}
+case 52:
+#line 501 "p-exp.y"
+{
+			  struct type *type = yyvsp[-2].tval;
+			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
+			      && TYPE_CODE (type) != TYPE_CODE_UNION)
+			    error ("`%s' is not defined as an aggregate type.",
+				   TYPE_NAME (type));
+
+			  write_exp_elt_opcode (OP_SCOPE);
+			  write_exp_elt_type (type);
+			  write_exp_string (yyvsp[0].sval);
+			  write_exp_elt_opcode (OP_SCOPE);
+			;
+    break;}
+case 54:
+#line 517 "p-exp.y"
+{
+			  char *name = copy_name (yyvsp[0].sval);
+			  struct symbol *sym;
+			  struct minimal_symbol *msymbol;
+
+			  sym =
+			    lookup_symbol (name, (const struct block *) NULL,
+					   VAR_NAMESPACE, (int *) NULL,
+					   (struct symtab **) NULL);
+			  if (sym)
+			    {
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      write_exp_elt_block (NULL);
+			      write_exp_elt_sym (sym);
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      break;
+			    }
+
+			  msymbol = lookup_minimal_symbol (name, NULL, NULL);
+			  if (msymbol != NULL)
+			    {
+			      write_exp_msymbol (msymbol,
+						 lookup_function_type (builtin_type_int),
+						 builtin_type_int);
+			    }
+			  else
+			    if (!have_full_symbols () && !have_partial_symbols ())
+			      error ("No symbol table is loaded.  Use the \"file\" command.");
+			    else
+			      error ("No symbol \"%s\" in current context.", name);
+			;
+    break;}
+case 55:
+#line 551 "p-exp.y"
+{ struct symbol *sym = yyvsp[0].ssym.sym;
+
+			  if (sym)
+			    {
+			      if (symbol_read_needs_frame (sym))
+				{
+				  if (innermost_block == 0 ||
+				      contained_in (block_found,
+						    innermost_block))
+				    innermost_block = block_found;
+				}
+
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      /* We want to use the selected frame, not
+				 another more inner frame which happens to
+				 be in the same block.  */
+			      write_exp_elt_block (NULL);
+			      write_exp_elt_sym (sym);
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			    }
+			  else if (yyvsp[0].ssym.is_a_field_of_this)
+			    {
+			      /* Object pascal: it hangs off of `this'.  Must
+			         not inadvertently convert from a method call
+				 to data ref.  */
+			      if (innermost_block == 0 ||
+				  contained_in (block_found, innermost_block))
+				innermost_block = block_found;
+			      write_exp_elt_opcode (OP_THIS);
+			      write_exp_elt_opcode (OP_THIS);
+			      write_exp_elt_opcode (STRUCTOP_PTR);
+			      write_exp_string (yyvsp[0].ssym.stoken);
+			      write_exp_elt_opcode (STRUCTOP_PTR);
+			    }
+			  else
+			    {
+			      struct minimal_symbol *msymbol;
+			      register char *arg = copy_name (yyvsp[0].ssym.stoken);
+
+			      msymbol =
+				lookup_minimal_symbol (arg, NULL, NULL);
+			      if (msymbol != NULL)
+				{
+				  write_exp_msymbol (msymbol,
+						     lookup_function_type (builtin_type_int),
+						     builtin_type_int);
+				}
+			      else if (!have_full_symbols () && !have_partial_symbols ())
+				error ("No symbol table is loaded.  Use the \"file\" command.");
+			      else
+				error ("No symbol \"%s\" in current context.",
+				       copy_name (yyvsp[0].ssym.stoken));
+			    }
+			;
+    break;}
+case 58:
+#line 621 "p-exp.y"
+{ yyval.tval = lookup_member_type (builtin_type_int, yyvsp[-2].tval); ;
+    break;}
+case 59:
+#line 626 "p-exp.y"
+{ yyval.tval = yyvsp[0].tsym.type; ;
+    break;}
+case 60:
+#line 628 "p-exp.y"
+{ yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+					      expression_context_block); ;
+    break;}
+case 61:
+#line 631 "p-exp.y"
+{ yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+					      expression_context_block); ;
+    break;}
+case 62:
+#line 638 "p-exp.y"
+{ yyval.sval = yyvsp[0].ssym.stoken; ;
+    break;}
+case 63:
+#line 639 "p-exp.y"
+{ yyval.sval = yyvsp[0].ssym.stoken; ;
+    break;}
+case 64:
+#line 640 "p-exp.y"
+{ yyval.sval = yyvsp[0].tsym.stoken; ;
+    break;}
+case 65:
+#line 641 "p-exp.y"
+{ yyval.sval = yyvsp[0].ssym.stoken; ;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 498 "/usr/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) xmalloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+}
+#line 655 "p-exp.y"
+
+
+/* Take care of parsing a number (anything that starts with a digit).
+   Set yylval and return the token type; update lexptr.
+   LEN is the number of characters in it.  */
+
+/*** Needs some error checking for the float case ***/
+
+static int
+parse_number (p, len, parsed_float, putithere)
+     register char *p;
+     register int len;
+     int parsed_float;
+     YYSTYPE *putithere;
+{
+  /* FIXME: Shouldn't these be unsigned?  We don't deal with negative values
+     here, and we do kind of silly things like cast to unsigned.  */
+  register LONGEST n = 0;
+  register LONGEST prevn = 0;
+  ULONGEST un;
+
+  register int i = 0;
+  register int c;
+  register int base = input_radix;
+  int unsigned_p = 0;
+
+  /* Number of "L" suffixes encountered.  */
+  int long_p = 0;
+
+  /* We have found a "L" or "U" suffix.  */
+  int found_suffix = 0;
+
+  ULONGEST high_bit;
+  struct type *signed_type;
+  struct type *unsigned_type;
+
+  if (parsed_float)
+    {
+      /* It's a float since it contains a point or an exponent.  */
+      char c;
+      int num = 0;	/* number of tokens scanned by scanf */
+      char saved_char = p[len];
+
+      p[len] = 0;	/* null-terminate the token */
+      if (sizeof (putithere->typed_val_float.dval) <= sizeof (float))
+	num = sscanf (p, "%g%c", (float *) &putithere->typed_val_float.dval,&c);
+      else if (sizeof (putithere->typed_val_float.dval) <= sizeof (double))
+	num = sscanf (p, "%lg%c", (double *) &putithere->typed_val_float.dval,&c);
+      else
+	{
+#ifdef SCANF_HAS_LONG_DOUBLE
+	  num = sscanf (p, "%Lg%c", &putithere->typed_val_float.dval,&c);
+#else
+	  /* Scan it into a double, then assign it to the long double.
+	     This at least wins with values representable in the range
+	     of doubles. */
+	  double temp;
+	  num = sscanf (p, "%lg%c", &temp,&c);
+	  putithere->typed_val_float.dval = temp;
+#endif
+	}
+      p[len] = saved_char;	/* restore the input stream */
+      if (num != 1) 		/* check scanf found ONLY a float ... */
+	return ERROR;
+      /* See if it has `f' or `l' suffix (float or long double).  */
+
+      c = tolower (p[len - 1]);
+
+      if (c == 'f')
+	putithere->typed_val_float.type = builtin_type_float;
+      else if (c == 'l')
+	putithere->typed_val_float.type = builtin_type_long_double;
+      else if (isdigit (c) || c == '.')
+	putithere->typed_val_float.type = builtin_type_double;
+      else
+	return ERROR;
+
+      return FLOAT;
+    }
+
+  /* Handle base-switching prefixes 0x, 0t, 0d, 0 */
+  if (p[0] == '0')
+    switch (p[1])
+      {
+      case 'x':
+      case 'X':
+	if (len >= 3)
+	  {
+	    p += 2;
+	    base = 16;
+	    len -= 2;
+	  }
+	break;
+
+      case 't':
+      case 'T':
+      case 'd':
+      case 'D':
+	if (len >= 3)
+	  {
+	    p += 2;
+	    base = 10;
+	    len -= 2;
+	  }
+	break;
+
+      default:
+	base = 8;
+	break;
+      }
+
+  while (len-- > 0)
+    {
+      c = *p++;
+      if (c >= 'A' && c <= 'Z')
+	c += 'a' - 'A';
+      if (c != 'l' && c != 'u')
+	n *= base;
+      if (c >= '0' && c <= '9')
+	{
+	  if (found_suffix)
+	    return ERROR;
+	  n += i = c - '0';
+	}
+      else
+	{
+	  if (base > 10 && c >= 'a' && c <= 'f')
+	    {
+	      if (found_suffix)
+		return ERROR;
+	      n += i = c - 'a' + 10;
+	    }
+	  else if (c == 'l')
+	    {
+	      ++long_p;
+	      found_suffix = 1;
+	    }
+	  else if (c == 'u')
+	    {
+	      unsigned_p = 1;
+	      found_suffix = 1;
+	    }
+	  else
+	    return ERROR;	/* Char not a digit */
+	}
+      if (i >= base)
+	return ERROR;		/* Invalid digit in this base */
+
+      /* Portably test for overflow (only works for nonzero values, so make
+	 a second check for zero).  FIXME: Can't we just make n and prevn
+	 unsigned and avoid this?  */
+      if (c != 'l' && c != 'u' && (prevn >= n) && n != 0)
+	unsigned_p = 1;		/* Try something unsigned */
+
+      /* Portably test for unsigned overflow.
+	 FIXME: This check is wrong; for example it doesn't find overflow
+	 on 0x123456789 when LONGEST is 32 bits.  */
+      if (c != 'l' && c != 'u' && n != 0)
+	{	
+	  if ((unsigned_p && (ULONGEST) prevn >= (ULONGEST) n))
+	    error ("Numeric constant too large.");
+	}
+      prevn = n;
+    }
+
+  /* An integer constant is an int, a long, or a long long.  An L
+     suffix forces it to be long; an LL suffix forces it to be long
+     long.  If not forced to a larger size, it gets the first type of
+     the above that it fits in.  To figure out whether it fits, we
+     shift it right and see whether anything remains.  Note that we
+     can't shift sizeof (LONGEST) * HOST_CHAR_BIT bits or more in one
+     operation, because many compilers will warn about such a shift
+     (which always produces a zero result).  Sometimes TARGET_INT_BIT
+     or TARGET_LONG_BIT will be that big, sometimes not.  To deal with
+     the case where it is we just always shift the value more than
+     once, with fewer bits each time.  */
+
+  un = (ULONGEST)n >> 2;
+  if (long_p == 0
+      && (un >> (TARGET_INT_BIT - 2)) == 0)
+    {
+      high_bit = ((ULONGEST)1) << (TARGET_INT_BIT-1);
+
+      /* A large decimal (not hex or octal) constant (between INT_MAX
+	 and UINT_MAX) is a long or unsigned long, according to ANSI,
+	 never an unsigned int, but this code treats it as unsigned
+	 int.  This probably should be fixed.  GCC gives a warning on
+	 such constants.  */
+
+      unsigned_type = builtin_type_unsigned_int;
+      signed_type = builtin_type_int;
+    }
+  else if (long_p <= 1
+	   && (un >> (TARGET_LONG_BIT - 2)) == 0)
+    {
+      high_bit = ((ULONGEST)1) << (TARGET_LONG_BIT-1);
+      unsigned_type = builtin_type_unsigned_long;
+      signed_type = builtin_type_long;
+    }
+  else
+    {
+      high_bit = (((ULONGEST)1)
+		  << (TARGET_LONG_LONG_BIT - 32 - 1)
+		  << 16
+		  << 16);
+      if (high_bit == 0)
+	/* A long long does not fit in a LONGEST.  */
+	high_bit =
+	  (ULONGEST)1 << (sizeof (LONGEST) * HOST_CHAR_BIT - 1);
+      unsigned_type = builtin_type_unsigned_long_long;
+      signed_type = builtin_type_long_long;
+    }
+
+   putithere->typed_val_int.val = n;
+
+   /* If the high bit of the worked out type is set then this number
+      has to be unsigned. */
+
+   if (unsigned_p || (n & high_bit))
+     {
+       putithere->typed_val_int.type = unsigned_type;
+     }
+   else
+     {
+       putithere->typed_val_int.type = signed_type;
+     }
+
+   return INT;
+}
+
+struct token
+{
+  char *operator;
+  int token;
+  enum exp_opcode opcode;
+};
+
+static const struct token tokentab3[] =
+  {
+    {"shr", RSH, BINOP_END},
+    {"shl", LSH, BINOP_END},
+    {"and", ANDAND, BINOP_END},
+    {"div", DIV, BINOP_END},
+    {"not", NOT, BINOP_END},
+    {"mod", MOD, BINOP_END},
+    {"inc", INCREMENT, BINOP_END},
+    {"dec", DECREMENT, BINOP_END},
+    {"xor", XOR, BINOP_END}
+  };
+
+static const struct token tokentab2[] =
+  {
+    {"or", OR, BINOP_END},
+    {"<>", NOTEQUAL, BINOP_END},
+    {"<=", LEQ, BINOP_END},
+    {">=", GEQ, BINOP_END},
+    {":=", ASSIGN, BINOP_END}
+  };
+
+/* Allocate uppercased var */
+/* make an uppercased copy of tokstart */
+static char * uptok (tokstart, namelen)
+  char *tokstart;
+  int namelen;
+{
+  int i;
+  char *uptokstart = (char *)xmalloc(namelen+1);
+  for (i = 0;i <= namelen;i++)
+    {
+      if ((tokstart[i]>='a' && tokstart[i]<='z'))
+        uptokstart[i] = tokstart[i]-('a'-'A');
+      else
+        uptokstart[i] = tokstart[i];
+    }
+  uptokstart[namelen]='\0';
+  return uptokstart;
+}
+/* Read one token, getting characters through lexptr.  */
+
+
+static int
+yylex ()
+{
+  int c;
+  int namelen;
+  unsigned int i;
+  char *tokstart;
+  char *uptokstart;
+  char *tokptr;
+  char *p;
+  int tempbufindex;
+  static char *tempbuf;
+  static int tempbufsize;
+
+ retry:
+
+  tokstart = lexptr;
+  /* See if it is a special token of length 3.  */
+  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)
+    if (STREQN (tokstart, tokentab3[i].operator, 3))
+      {
+	lexptr += 3;
+	yylval.opcode = tokentab3[i].opcode;
+	return tokentab3[i].token;
+      }
+
+  /* See if it is a special token of length 2.  */
+  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)
+    if (STREQN (tokstart, tokentab2[i].operator, 2))
+      {
+	lexptr += 2;
+	yylval.opcode = tokentab2[i].opcode;
+	return tokentab2[i].token;
+      }
+
+  switch (c = *tokstart)
+    {
+    case 0:
+      return 0;
+
+    case ' ':
+    case '\t':
+    case '\n':
+      lexptr++;
+      goto retry;
+
+    case '\'':
+      /* We either have a character constant ('0' or '\177' for example)
+	 or we have a quoted symbol reference ('foo(int,int)' in object pascal
+	 for example). */
+      lexptr++;
+      c = *lexptr++;
+      if (c == '\\')
+	c = parse_escape (&lexptr);
+      else if (c == '\'')
+	error ("Empty character constant.");
+
+      yylval.typed_val_int.val = c;
+      yylval.typed_val_int.type = builtin_type_char;
+
+      c = *lexptr++;
+      if (c != '\'')
+	{
+	  namelen = skip_quoted (tokstart) - tokstart;
+	  if (namelen > 2)
+	    {
+	      lexptr = tokstart + namelen;
+	      if (lexptr[-1] != '\'')
+		error ("Unmatched single quote.");
+	      namelen -= 2;
+              tokstart++;
+              uptokstart = uptok(tokstart,namelen);
+	      goto tryname;
+	    }
+	  error ("Invalid character constant.");
+	}
+      return INT;
+
+    case '(':
+      paren_depth++;
+      lexptr++;
+      return c;
+
+    case ')':
+      if (paren_depth == 0)
+	return 0;
+      paren_depth--;
+      lexptr++;
+      return c;
+
+    case ',':
+      if (comma_terminates && paren_depth == 0)
+	return 0;
+      lexptr++;
+      return c;
+
+    case '.':
+      /* Might be a floating point number.  */
+      if (lexptr[1] < '0' || lexptr[1] > '9')
+	goto symbol;		/* Nope, must be a symbol. */
+      /* FALL THRU into number case.  */
+
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+      {
+	/* It's a number.  */
+	int got_dot = 0, got_e = 0, toktype;
+	register char *p = tokstart;
+	int hex = input_radix > 10;
+
+	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
+	  {
+	    p += 2;
+	    hex = 1;
+	  }
+	else if (c == '0' && (p[1]=='t' || p[1]=='T' || p[1]=='d' || p[1]=='D'))
+	  {
+	    p += 2;
+	    hex = 0;
+	  }
+
+	for (;; ++p)
+	  {
+	    /* This test includes !hex because 'e' is a valid hex digit
+	       and thus does not indicate a floating point number when
+	       the radix is hex.  */
+	    if (!hex && !got_e && (*p == 'e' || *p == 'E'))
+	      got_dot = got_e = 1;
+	    /* This test does not include !hex, because a '.' always indicates
+	       a decimal floating point number regardless of the radix.  */
+	    else if (!got_dot && *p == '.')
+	      got_dot = 1;
+	    else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
+		     && (*p == '-' || *p == '+'))
+	      /* This is the sign of the exponent, not the end of the
+		 number.  */
+	      continue;
+	    /* We will take any letters or digits.  parse_number will
+	       complain if past the radix, or if L or U are not final.  */
+	    else if ((*p < '0' || *p > '9')
+		     && ((*p < 'a' || *p > 'z')
+				  && (*p < 'A' || *p > 'Z')))
+	      break;
+	  }
+	toktype = parse_number (tokstart, p - tokstart, got_dot|got_e, &yylval);
+        if (toktype == ERROR)
+	  {
+	    char *err_copy = (char *) alloca (p - tokstart + 1);
+
+	    memcpy (err_copy, tokstart, p - tokstart);
+	    err_copy[p - tokstart] = 0;
+	    error ("Invalid number \"%s\".", err_copy);
+	  }
+	lexptr = p;
+	return toktype;
+      }
+
+    case '+':
+    case '-':
+    case '*':
+    case '/':
+    case '|':
+    case '&':
+    case '^':
+    case '~':
+    case '!':
+    case '@':
+    case '<':
+    case '>':
+    case '[':
+    case ']':
+    case '?':
+    case ':':
+    case '=':
+    case '{':
+    case '}':
+    symbol:
+      lexptr++;
+      return c;
+
+    case '"':
+
+      /* Build the gdb internal form of the input string in tempbuf,
+	 translating any standard C escape forms seen.  Note that the
+	 buffer is null byte terminated *only* for the convenience of
+	 debugging gdb itself and printing the buffer contents when
+	 the buffer contains no embedded nulls.  Gdb does not depend
+	 upon the buffer being null byte terminated, it uses the length
+	 string instead.  This allows gdb to handle C strings (as well
+	 as strings in other languages) with embedded null bytes */
+
+      tokptr = ++tokstart;
+      tempbufindex = 0;
+
+      do {
+	/* Grow the static temp buffer if necessary, including allocating
+	   the first one on demand. */
+	if (tempbufindex + 1 >= tempbufsize)
+	  {
+	    tempbuf = (char *) xrealloc (tempbuf, tempbufsize += 64);
+	  }
+	switch (*tokptr)
+	  {
+	  case '\0':
+	  case '"':
+	    /* Do nothing, loop will terminate. */
+	    break;
+	  case '\\':
+	    tokptr++;
+	    c = parse_escape (&tokptr);
+	    if (c == -1)
+	      {
+		continue;
+	      }
+	    tempbuf[tempbufindex++] = c;
+	    break;
+	  default:
+	    tempbuf[tempbufindex++] = *tokptr++;
+	    break;
+	  }
+      } while ((*tokptr != '"') && (*tokptr != '\0'));
+      if (*tokptr++ != '"')
+	{
+	  error ("Unterminated string in expression.");
+	}
+      tempbuf[tempbufindex] = '\0';	/* See note above */
+      yylval.sval.ptr = tempbuf;
+      yylval.sval.length = tempbufindex;
+      lexptr = tokptr;
+      return (STRING);
+    }
+
+  if (!(c == '_' || c == '$'
+	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
+    /* We must have come across a bad character (e.g. ';').  */
+    error ("Invalid character '%c' in expression.", c);
+
+  /* It's a name.  See how long it is.  */
+  namelen = 0;
+  for (c = tokstart[namelen];
+       (c == '_' || c == '$' || (c >= '0' && c <= '9')
+	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '<');)
+    {
+      /* Template parameter lists are part of the name.
+	 FIXME: This mishandles `print $a<4&&$a>3'.  */
+      if (c == '<')
+	{
+	  int i = namelen;
+	  int nesting_level = 1;
+	  while (tokstart[++i])
+	    {
+	      if (tokstart[i] == '<')
+		nesting_level++;
+	      else if (tokstart[i] == '>')
+		{
+		  if (--nesting_level == 0)
+		    break;
+		}
+	    }
+	  if (tokstart[i] == '>')
+	    namelen = i;
+	  else
+	    break;
+	}
+
+      /* do NOT uppercase internals because of registers !!! */
+      c = tokstart[++namelen];
+    }
+
+  uptokstart = uptok(tokstart,namelen);
+
+  /* The token "if" terminates the expression and is NOT
+     removed from the input stream.  */
+  if (namelen == 2 && uptokstart[0] == 'I' && uptokstart[1] == 'F')
+    {
+      return 0;
+    }
+
+  lexptr += namelen;
+
+  tryname:
+
+  /* Catch specific keywords.  Should be done with a data structure.  */
+  switch (namelen)
+    {
+    case 6:
+      if (STREQ (uptokstart, "OBJECT"))
+	return CLASS;
+      if (STREQ (uptokstart, "RECORD"))
+	return STRUCT;
+      if (STREQ (uptokstart, "SIZEOF"))
+	return SIZEOF;
+      break;
+    case 5:
+      if (STREQ (uptokstart, "CLASS"))
+	return CLASS;
+      if (STREQ (uptokstart, "FALSE"))
+	{
+          yylval.lval = 0;
+          return FALSE;
+        }
+      break;
+    case 4:
+      if (STREQ (uptokstart, "TRUE"))
+	{
+          yylval.lval = 1;
+  	  return TRUE;
+        }
+      if (STREQ (uptokstart, "SELF"))
+        {
+          /* here we search for 'this' like
+             inserted in FPC stabs debug info */
+	  static const char this_name[] =
+				 { /* CPLUS_MARKER,*/ 't', 'h', 'i', 's', '\0' };
+
+	  if (lookup_symbol (this_name, expression_context_block,
+			     VAR_NAMESPACE, (int *) NULL,
+			     (struct symtab **) NULL))
+	    return THIS;
+	}
+      break;
+    default:
+      break;
+    }
+
+  yylval.sval.ptr = tokstart;
+  yylval.sval.length = namelen;
+
+  if (*tokstart == '$')
+    {
+      /* $ is the normal prefix for pascal hexadecimal values
+        but this conflicts with the GDB use for debugger variables
+        so in expression to enter hexadecimal values
+        we still need to use C syntax with 0xff  */
+      write_dollar_variable (yylval.sval);
+      return VARIABLE;
+    }
+
+  /* Use token-type BLOCKNAME for symbols that happen to be defined as
+     functions or symtabs.  If this is not so, then ...
+     Use token-type TYPENAME for symbols that happen to be defined
+     currently as names of types; NAME for other symbols.
+     The caller is not constrained to care about the distinction.  */
+  {
+    char *tmp = copy_name (yylval.sval);
+    struct symbol *sym;
+    int is_a_field_of_this = 0;
+    int hextype;
+
+    sym = lookup_symbol (tmp, expression_context_block,
+			 VAR_NAMESPACE,
+			 &is_a_field_of_this,
+			 (struct symtab **) NULL);
+    /* second chance uppercased ! */
+    if (!sym)
+      {
+       for (i = 0;i <= namelen;i++)
+         {
+           if ((tmp[i]>='a' && tmp[i]<='z'))
+             tmp[i] -= ('a'-'A');
+           /* I am not sure that copy_name gives excatly the same result ! */
+           if ((tokstart[i]>='a' && tokstart[i]<='z'))
+             tokstart[i] -= ('a'-'A');
+         }
+        sym = lookup_symbol (tmp, expression_context_block,
+			 VAR_NAMESPACE,
+			 &is_a_field_of_this,
+			 (struct symtab **) NULL);
+      }
+    /* Call lookup_symtab, not lookup_partial_symtab, in case there are
+       no psymtabs (coff, xcoff, or some future change to blow away the
+       psymtabs once once symbols are read).  */
+    if ((sym && SYMBOL_CLASS (sym) == LOC_BLOCK) ||
+        lookup_symtab (tmp))
+      {
+	yylval.ssym.sym = sym;
+	yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+	return BLOCKNAME;
+      }
+    if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
+        {
+#if 1
+	  /* Despite the following flaw, we need to keep this code enabled.
+	     Because we can get called from check_stub_method, if we don't
+	     handle nested types then it screws many operations in any
+	     program which uses nested types.  */
+	  /* In "A::x", if x is a member function of A and there happens
+	     to be a type (nested or not, since the stabs don't make that
+	     distinction) named x, then this code incorrectly thinks we
+	     are dealing with nested types rather than a member function.  */
+
+	  char *p;
+	  char *namestart;
+	  struct symbol *best_sym;
+
+	  /* Look ahead to detect nested types.  This probably should be
+	     done in the grammar, but trying seemed to introduce a lot
+	     of shift/reduce and reduce/reduce conflicts.  It's possible
+	     that it could be done, though.  Or perhaps a non-grammar, but
+	     less ad hoc, approach would work well.  */
+
+	  /* Since we do not currently have any way of distinguishing
+	     a nested type from a non-nested one (the stabs don't tell
+	     us whether a type is nested), we just ignore the
+	     containing type.  */
+
+	  p = lexptr;
+	  best_sym = sym;
+	  while (1)
+	    {
+	      /* Skip whitespace.  */
+	      while (*p == ' ' || *p == '\t' || *p == '\n')
+		++p;
+	      if (*p == ':' && p[1] == ':')
+		{
+		  /* Skip the `::'.  */
+		  p += 2;
+		  /* Skip whitespace.  */
+		  while (*p == ' ' || *p == '\t' || *p == '\n')
+		    ++p;
+		  namestart = p;
+		  while (*p == '_' || *p == '$' || (*p >= '0' && *p <= '9')
+			 || (*p >= 'a' && *p <= 'z')
+			 || (*p >= 'A' && *p <= 'Z'))
+		    ++p;
+		  if (p != namestart)
+		    {
+		      struct symbol *cur_sym;
+		      /* As big as the whole rest of the expression, which is
+			 at least big enough.  */
+		      char *ncopy = alloca (strlen (tmp)+strlen (namestart)+3);
+		      char *tmp1;
+
+		      tmp1 = ncopy;
+		      memcpy (tmp1, tmp, strlen (tmp));
+		      tmp1 += strlen (tmp);
+		      memcpy (tmp1, "::", 2);
+		      tmp1 += 2;
+		      memcpy (tmp1, namestart, p - namestart);
+		      tmp1[p - namestart] = '\0';
+		      cur_sym = lookup_symbol (ncopy, expression_context_block,
+					       VAR_NAMESPACE, (int *) NULL,
+					       (struct symtab **) NULL);
+		      if (cur_sym)
+			{
+			  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)
+			    {
+			      best_sym = cur_sym;
+			      lexptr = p;
+			    }
+			  else
+			    break;
+			}
+		      else
+			break;
+		    }
+		  else
+		    break;
+		}
+	      else
+		break;
+	    }
+
+	  yylval.tsym.type = SYMBOL_TYPE (best_sym);
+#else /* not 0 */
+	  yylval.tsym.type = SYMBOL_TYPE (sym);
+#endif /* not 0 */
+	  return TYPENAME;
+        }
+    if ((yylval.tsym.type = lookup_primitive_typename (tmp)) != 0)
+	return TYPENAME;
+
+    /* Input names that aren't symbols but ARE valid hex numbers,
+       when the input radix permits them, can be names or numbers
+       depending on the parse.  Note we support radixes > 16 here.  */
+    if (!sym &&
+        ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10) ||
+         (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10)))
+      {
+ 	YYSTYPE newlval;	/* Its value is ignored.  */
+	hextype = parse_number (tokstart, namelen, 0, &newlval);
+	if (hextype == INT)
+	  {
+	    yylval.ssym.sym = sym;
+	    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+	    return NAME_OR_INT;
+	  }
+      }
+
+    free(uptokstart);
+    /* Any other kind of symbol */
+    yylval.ssym.sym = sym;
+    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+    return NAME;
+  }
+}
+
+void
+yyerror (msg)
+     char *msg;
+{
+  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
+}
+
diff -urN origdb/p-exp.y gdb/p-exp.y
--- origdb/p-exp.y	Thu Jan  1 00:00:00 1970
+++ gdb/p-exp.y	Fri Nov  3 11:29:10 2000
@@ -0,0 +1,1446 @@
+/* YACC parser for Pascal expressions, for GDB.
+   Copyright (C) 2000
+   Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file is derived from c-exp.y */
+
+/* Parse a Pascal expression from text in a string,
+   and return the result as a  struct expression  pointer.
+   That structure contains arithmetic operations in reverse polish,
+   with constants represented by operations that are followed by special data.
+   See expression.h for the details of the format.
+   What is important here is that it can be built up sequentially
+   during the process of parsing; the lower levels of the tree always
+   come first in the result.
+
+   Note that malloc's and realloc's in this file are transformed to
+   xmalloc and xrealloc respectively by the same sed command in the
+   makefile that remaps any other malloc/realloc inserted by the parser
+   generator.  Doing this with #defines and trying to control the interaction
+   with include files (<malloc.h> and <stdlib.h> for example) just became
+   too messy, particularly when such includes can be inserted at random
+   times by the parser generator.  */
+
+/* FIXME: there are still 21 shift/reduce conflicts
+   Other known bugs or limitations:
+    - pascal string operations are not supported at all.
+    - there are some problems with boolean types.
+    - Pascal type hexadecimal constants are not supported
+      because they conflict with the internal variables format.
+   Probably also lots of other problems, less well defined PM */
+%{
+
+#include "defs.h"
+#include "gdb_string.h"
+#include <ctype.h>
+#include "expression.h"
+#include "value.h"
+#include "parser-defs.h"
+#include "language.h"
+#include "p-lang.h"
+#include "bfd.h" /* Required by objfiles.h.  */
+#include "symfile.h" /* Required by objfiles.h.  */
+#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
+
+/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
+   as well as gratuitiously global symbol names, so we can have multiple
+   yacc generated parsers in gdb.  Note that these are only the variables
+   produced by yacc.  If other parser generators (bison, byacc, etc) produce
+   additional global names that conflict at link time, then those parser
+   generators need to be fixed instead of adding those names to this list. */
+
+#define	yymaxdepth pascal_maxdepth
+#define	yyparse	pascal_parse
+#define	yylex	pascal_lex
+#define	yyerror	pascal_error
+#define	yylval	pascal_lval
+#define	yychar	pascal_char
+#define	yydebug	pascal_debug
+#define	yypact	pascal_pact	
+#define	yyr1	pascal_r1			
+#define	yyr2	pascal_r2			
+#define	yydef	pascal_def		
+#define	yychk	pascal_chk		
+#define	yypgo	pascal_pgo		
+#define	yyact	pascal_act
+#define	yyexca	pascal_exca
+#define yyerrflag pascal_errflag
+#define yynerrs	pascal_nerrs
+#define	yyps	pascal_ps
+#define	yypv	pascal_pv
+#define	yys	pascal_s
+#define	yy_yys	pascal_yys
+#define	yystate	pascal_state
+#define	yytmp	pascal_tmp
+#define	yyv	pascal_v
+#define	yy_yyv	pascal_yyv
+#define	yyval	pascal_val
+#define	yylloc	pascal_lloc
+#define yyreds	pascal_reds		/* With YYDEBUG defined */
+#define yytoks	pascal_toks		/* With YYDEBUG defined */
+#define yylhs	pascal_yylhs
+#define yylen	pascal_yylen
+#define yydefred pascal_yydefred
+#define yydgoto	pascal_yydgoto
+#define yysindex pascal_yysindex
+#define yyrindex pascal_yyrindex
+#define yygindex pascal_yygindex
+#define yytable	 pascal_yytable
+#define yycheck	 pascal_yycheck
+
+#ifndef YYDEBUG
+#define	YYDEBUG	0		/* Default to no yydebug support */
+#endif
+
+int yyparse (void);
+
+static int yylex (void);
+
+void
+yyerror (char *);
+
+static char * uptok (char *, int);
+%}
+
+/* Although the yacc "value" of an expression is not used,
+   since the result is stored in the structure being created,
+   other node types do have values.  */
+
+%union
+  {
+    LONGEST lval;
+    struct {
+      LONGEST val;
+      struct type *type;
+    } typed_val_int;
+    struct {
+      DOUBLEST dval;
+      struct type *type;
+    } typed_val_float;
+    struct symbol *sym;
+    struct type *tval;
+    struct stoken sval;
+    struct ttype tsym;
+    struct symtoken ssym;
+    int voidval;
+    struct block *bval;
+    enum exp_opcode opcode;
+    struct internalvar *ivar;
+
+    struct type **tvec;
+    int *ivec;
+  }
+
+%{
+/* YYSTYPE gets defined by %union */
+static int
+parse_number (char *, int, int, YYSTYPE *);
+%}
+
+%type <voidval> exp exp1 type_exp start variable qualified_name
+%type <tval> type typebase
+/* %type <bval> block */
+
+/* Fancy type parsing.  */
+%type <tval> ptype
+
+%token <typed_val_int> INT
+%token <typed_val_float> FLOAT
+
+/* Both NAME and TYPENAME tokens represent symbols in the input,
+   and both convey their data as strings.
+   But a TYPENAME is a string that happens to be defined as a typedef
+   or builtin type name (such as int or char)
+   and a NAME is any other symbol.
+   Contexts where this distinction is not important can use the
+   nonterminal "name", which matches either NAME or TYPENAME.  */
+
+%token <sval> STRING
+%token <ssym> NAME /* BLOCKNAME defined below to give it higher precedence. */
+%token <tsym> TYPENAME
+%type <sval> name
+%type <ssym> name_not_typename
+
+/* A NAME_OR_INT is a symbol which is not known in the symbol table,
+   but which would parse as a valid number in the current input radix.
+   E.g. "c" when input_radix==16.  Depending on the parse, it will be
+   turned into a name or into a number.  */
+
+%token <ssym> NAME_OR_INT
+
+%token STRUCT CLASS SIZEOF COLONCOLON
+%token ERROR
+
+/* Special type cases, put in to allow the parser to distinguish different
+   legal basetypes.  */
+
+%token <voidval> VARIABLE
+
+
+/* Object pascal */
+%token THIS
+%token <lval> TRUE FALSE
+
+%left ','
+%left ABOVE_COMMA
+%right ASSIGN
+%left NOT
+%left OR
+%left XOR
+%left ANDAND
+%left '=' NOTEQUAL
+%left '<' '>' LEQ GEQ
+%left LSH RSH DIV MOD
+%left '@'
+%left '+' '-'
+%left '*' '/'
+%right UNARY INCREMENT DECREMENT
+%right ARROW '.' '[' '('
+%token <ssym> BLOCKNAME
+%type <bval> block
+%left COLONCOLON
+
+
+%%
+
+start   :	exp1
+	|	type_exp
+	;
+
+type_exp:	type
+			{ write_exp_elt_opcode(OP_TYPE);
+			  write_exp_elt_type($1);
+			  write_exp_elt_opcode(OP_TYPE);}
+	;
+
+/* Expressions, including the comma operator.  */
+exp1	:	exp
+	|	exp1 ',' exp
+			{ write_exp_elt_opcode (BINOP_COMMA); }
+	;
+
+/* Expressions, not including the comma operator.  */
+exp	:	exp '^'   %prec UNARY
+			{ write_exp_elt_opcode (UNOP_IND); }
+
+exp	:	'@' exp    %prec UNARY
+			{ write_exp_elt_opcode (UNOP_ADDR); }
+
+exp	:	'-' exp    %prec UNARY
+			{ write_exp_elt_opcode (UNOP_NEG); }
+	;
+
+exp	:	NOT exp    %prec UNARY
+			{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); }
+	;
+
+exp	:	INCREMENT '(' exp ')'   %prec UNARY
+			{ write_exp_elt_opcode (UNOP_PREINCREMENT); }
+	;
+
+exp	:	DECREMENT  '(' exp ')'   %prec UNARY
+			{ write_exp_elt_opcode (UNOP_PREDECREMENT); }
+	;
+
+exp	:	exp '.' name
+			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
+			  write_exp_string ($3);
+			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
+	;
+
+exp	:	exp '[' exp1 ']'
+			{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
+	;
+
+exp	:	exp '('
+			/* This is to save the value of arglist_len
+			   being accumulated by an outer function call.  */
+			{ start_arglist (); }
+		arglist ')'	%prec ARROW
+			{ write_exp_elt_opcode (OP_FUNCALL);
+			  write_exp_elt_longcst ((LONGEST) end_arglist ());
+			  write_exp_elt_opcode (OP_FUNCALL); }
+	;
+
+arglist	:
+         | exp
+			{ arglist_len = 1; }
+	 | arglist ',' exp   %prec ABOVE_COMMA
+			{ arglist_len++; }
+	;
+
+exp	:	type '(' exp ')' %prec UNARY
+			{ write_exp_elt_opcode (UNOP_CAST);
+			  write_exp_elt_type ($1);
+			  write_exp_elt_opcode (UNOP_CAST); }
+	;
+
+exp	:	'(' exp1 ')'
+			{ }
+	;
+
+/* Binary operators in order of decreasing precedence.  */
+
+exp	:	exp '*' exp
+			{ write_exp_elt_opcode (BINOP_MUL); }
+	;
+
+exp	:	exp '/' exp
+			{ write_exp_elt_opcode (BINOP_DIV); }
+	;
+
+exp	:	exp DIV exp
+			{ write_exp_elt_opcode (BINOP_INTDIV); }
+	;
+
+exp	:	exp MOD exp
+			{ write_exp_elt_opcode (BINOP_REM); }
+	;
+
+exp	:	exp '+' exp
+			{ write_exp_elt_opcode (BINOP_ADD); }
+	;
+
+exp	:	exp '-' exp
+			{ write_exp_elt_opcode (BINOP_SUB); }
+	;
+
+exp	:	exp LSH exp
+			{ write_exp_elt_opcode (BINOP_LSH); }
+	;
+
+exp	:	exp RSH exp
+			{ write_exp_elt_opcode (BINOP_RSH); }
+	;
+
+exp	:	exp '=' exp
+			{ write_exp_elt_opcode (BINOP_EQUAL); }
+	;
+
+exp	:	exp NOTEQUAL exp
+			{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
+	;
+
+exp	:	exp LEQ exp
+			{ write_exp_elt_opcode (BINOP_LEQ); }
+	;
+
+exp	:	exp GEQ exp
+			{ write_exp_elt_opcode (BINOP_GEQ); }
+	;
+
+exp	:	exp '<' exp
+			{ write_exp_elt_opcode (BINOP_LESS); }
+	;
+
+exp	:	exp '>' exp
+			{ write_exp_elt_opcode (BINOP_GTR); }
+	;
+
+exp	:	exp ANDAND exp
+			{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
+	;
+
+exp	:	exp XOR exp
+			{ write_exp_elt_opcode (BINOP_BITWISE_XOR); }
+	;
+
+exp	:	exp OR exp
+			{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
+	;
+
+exp	:	exp ASSIGN exp
+			{ write_exp_elt_opcode (BINOP_ASSIGN); }
+	;
+
+exp	:	TRUE
+			{ write_exp_elt_opcode (OP_BOOL);
+			  write_exp_elt_longcst ((LONGEST) $1);
+			  write_exp_elt_opcode (OP_BOOL); }
+	;
+
+exp	:	FALSE
+			{ write_exp_elt_opcode (OP_BOOL);
+			  write_exp_elt_longcst ((LONGEST) $1);
+			  write_exp_elt_opcode (OP_BOOL); }
+	;
+
+exp	:	INT
+			{ write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type ($1.type);
+			  write_exp_elt_longcst ((LONGEST)($1.val));
+			  write_exp_elt_opcode (OP_LONG); }
+	;
+
+exp	:	NAME_OR_INT
+			{ YYSTYPE val;
+			  parse_number ($1.stoken.ptr, $1.stoken.length, 0, &val);
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (val.typed_val_int.type);
+			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
+			  write_exp_elt_opcode (OP_LONG);
+			}
+	;
+
+
+exp	:	FLOAT
+			{ write_exp_elt_opcode (OP_DOUBLE);
+			  write_exp_elt_type ($1.type);
+			  write_exp_elt_dblcst ($1.dval);
+			  write_exp_elt_opcode (OP_DOUBLE); }
+	;
+
+exp	:	variable
+	;
+
+exp	:	VARIABLE
+			/* Already written by write_dollar_variable. */
+	;
+
+exp	:	SIZEOF '(' type ')'	%prec UNARY
+			{ write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (builtin_type_int);
+			  CHECK_TYPEDEF ($3);
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ($3));
+			  write_exp_elt_opcode (OP_LONG); }
+	;
+
+exp	:	STRING
+			{ /* C strings are converted into array constants with
+			     an explicit null byte added at the end.  Thus
+			     the array upper bound is the string length.
+			     There is no such thing in C as a completely empty
+			     string. */
+			  char *sp = $1.ptr; int count = $1.length;
+			  while (count-- > 0)
+			    {
+			      write_exp_elt_opcode (OP_LONG);
+			      write_exp_elt_type (builtin_type_char);
+			      write_exp_elt_longcst ((LONGEST)(*sp++));
+			      write_exp_elt_opcode (OP_LONG);
+			    }
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_type (builtin_type_char);
+			  write_exp_elt_longcst ((LONGEST)'\0');
+			  write_exp_elt_opcode (OP_LONG);
+			  write_exp_elt_opcode (OP_ARRAY);
+			  write_exp_elt_longcst ((LONGEST) 0);
+			  write_exp_elt_longcst ((LONGEST) ($1.length));
+			  write_exp_elt_opcode (OP_ARRAY); }
+	;
+
+/* Object pascal  */
+exp	:	THIS
+			{ write_exp_elt_opcode (OP_THIS);
+			  write_exp_elt_opcode (OP_THIS); }
+	;
+
+/* end of object pascal.  */
+
+block	:	BLOCKNAME
+			{
+			  if ($1.sym != 0)
+			      $$ = SYMBOL_BLOCK_VALUE ($1.sym);
+			  else
+			    {
+			      struct symtab *tem =
+				  lookup_symtab (copy_name ($1.stoken));
+			      if (tem)
+				$$ = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
+			      else
+				error ("No file or function \"%s\".",
+				       copy_name ($1.stoken));
+			    }
+			}
+	;
+
+block	:	block COLONCOLON name
+			{ struct symbol *tem
+			    = lookup_symbol (copy_name ($3), $1,
+					     VAR_NAMESPACE, (int *) NULL,
+					     (struct symtab **) NULL);
+			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
+			    error ("No function \"%s\" in specified context.",
+				   copy_name ($3));
+			  $$ = SYMBOL_BLOCK_VALUE (tem); }
+	;
+
+variable:	block COLONCOLON name
+			{ struct symbol *sym;
+			  sym = lookup_symbol (copy_name ($3), $1,
+					       VAR_NAMESPACE, (int *) NULL,
+					       (struct symtab **) NULL);
+			  if (sym == 0)
+			    error ("No symbol \"%s\" in specified context.",
+				   copy_name ($3));
+
+			  write_exp_elt_opcode (OP_VAR_VALUE);
+			  /* block_found is set by lookup_symbol.  */
+			  write_exp_elt_block (block_found);
+			  write_exp_elt_sym (sym);
+			  write_exp_elt_opcode (OP_VAR_VALUE); }
+	;
+
+qualified_name:	typebase COLONCOLON name
+			{
+			  struct type *type = $1;
+			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
+			      && TYPE_CODE (type) != TYPE_CODE_UNION)
+			    error ("`%s' is not defined as an aggregate type.",
+				   TYPE_NAME (type));
+
+			  write_exp_elt_opcode (OP_SCOPE);
+			  write_exp_elt_type (type);
+			  write_exp_string ($3);
+			  write_exp_elt_opcode (OP_SCOPE);
+			}
+	;
+
+variable:	qualified_name
+	|	COLONCOLON name
+			{
+			  char *name = copy_name ($2);
+			  struct symbol *sym;
+			  struct minimal_symbol *msymbol;
+
+			  sym =
+			    lookup_symbol (name, (const struct block *) NULL,
+					   VAR_NAMESPACE, (int *) NULL,
+					   (struct symtab **) NULL);
+			  if (sym)
+			    {
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      write_exp_elt_block (NULL);
+			      write_exp_elt_sym (sym);
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      break;
+			    }
+
+			  msymbol = lookup_minimal_symbol (name, NULL, NULL);
+			  if (msymbol != NULL)
+			    {
+			      write_exp_msymbol (msymbol,
+						 lookup_function_type (builtin_type_int),
+						 builtin_type_int);
+			    }
+			  else
+			    if (!have_full_symbols () && !have_partial_symbols ())
+			      error ("No symbol table is loaded.  Use the \"file\" command.");
+			    else
+			      error ("No symbol \"%s\" in current context.", name);
+			}
+	;
+
+variable:	name_not_typename
+			{ struct symbol *sym = $1.sym;
+
+			  if (sym)
+			    {
+			      if (symbol_read_needs_frame (sym))
+				{
+				  if (innermost_block == 0 ||
+				      contained_in (block_found,
+						    innermost_block))
+				    innermost_block = block_found;
+				}
+
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			      /* We want to use the selected frame, not
+				 another more inner frame which happens to
+				 be in the same block.  */
+			      write_exp_elt_block (NULL);
+			      write_exp_elt_sym (sym);
+			      write_exp_elt_opcode (OP_VAR_VALUE);
+			    }
+			  else if ($1.is_a_field_of_this)
+			    {
+			      /* Object pascal: it hangs off of `this'.  Must
+			         not inadvertently convert from a method call
+				 to data ref.  */
+			      if (innermost_block == 0 ||
+				  contained_in (block_found, innermost_block))
+				innermost_block = block_found;
+			      write_exp_elt_opcode (OP_THIS);
+			      write_exp_elt_opcode (OP_THIS);
+			      write_exp_elt_opcode (STRUCTOP_PTR);
+			      write_exp_string ($1.stoken);
+			      write_exp_elt_opcode (STRUCTOP_PTR);
+			    }
+			  else
+			    {
+			      struct minimal_symbol *msymbol;
+			      register char *arg = copy_name ($1.stoken);
+
+			      msymbol =
+				lookup_minimal_symbol (arg, NULL, NULL);
+			      if (msymbol != NULL)
+				{
+				  write_exp_msymbol (msymbol,
+						     lookup_function_type (builtin_type_int),
+						     builtin_type_int);
+				}
+			      else if (!have_full_symbols () && !have_partial_symbols ())
+				error ("No symbol table is loaded.  Use the \"file\" command.");
+			      else
+				error ("No symbol \"%s\" in current context.",
+				       copy_name ($1.stoken));
+			    }
+			}
+	;
+
+
+ptype	:	typebase
+	;
+
+/* We used to try to recognize more pointer to member types here, but
+   that didn't work (shift/reduce conflicts meant that these rules never
+   got executed).  The problem is that
+     int (foo::bar::baz::bizzle)
+   is a function type but
+     int (foo::bar::baz::bizzle::*)
+   is a pointer to member type.  Stroustrup loses again!  */
+
+type	:	ptype
+	|	typebase COLONCOLON '*'
+			{ $$ = lookup_member_type (builtin_type_int, $1); }
+	;
+
+typebase  /* Implements (approximately): (type-qualifier)* type-specifier */
+	:	TYPENAME
+			{ $$ = $1.type; }
+	|	STRUCT name
+			{ $$ = lookup_struct (copy_name ($2),
+					      expression_context_block); }
+	|	CLASS name
+			{ $$ = lookup_struct (copy_name ($2),
+					      expression_context_block); }
+	/* "const" and "volatile" are curently ignored.  A type qualifier
+	   after the type is handled in the ptype rule.  I think these could
+	   be too.  */
+	;
+
+name	:	NAME { $$ = $1.stoken; }
+	|	BLOCKNAME { $$ = $1.stoken; }
+	|	TYPENAME { $$ = $1.stoken; }
+	|	NAME_OR_INT  { $$ = $1.stoken; }
+	;
+
+name_not_typename :	NAME
+	|	BLOCKNAME
+/* These would be useful if name_not_typename was useful, but it is just
+   a fake for "variable", so these cause reduce/reduce conflicts because
+   the parser can't tell whether NAME_OR_INT is a name_not_typename (=variable,
+   =exp) or just an exp.  If name_not_typename was ever used in an lvalue
+   context where only a name could occur, this might be useful.
+  	|	NAME_OR_INT
+ */
+	;
+
+%%
+
+/* Take care of parsing a number (anything that starts with a digit).
+   Set yylval and return the token type; update lexptr.
+   LEN is the number of characters in it.  */
+
+/*** Needs some error checking for the float case ***/
+
+static int
+parse_number (p, len, parsed_float, putithere)
+     register char *p;
+     register int len;
+     int parsed_float;
+     YYSTYPE *putithere;
+{
+  /* FIXME: Shouldn't these be unsigned?  We don't deal with negative values
+     here, and we do kind of silly things like cast to unsigned.  */
+  register LONGEST n = 0;
+  register LONGEST prevn = 0;
+  ULONGEST un;
+
+  register int i = 0;
+  register int c;
+  register int base = input_radix;
+  int unsigned_p = 0;
+
+  /* Number of "L" suffixes encountered.  */
+  int long_p = 0;
+
+  /* We have found a "L" or "U" suffix.  */
+  int found_suffix = 0;
+
+  ULONGEST high_bit;
+  struct type *signed_type;
+  struct type *unsigned_type;
+
+  if (parsed_float)
+    {
+      /* It's a float since it contains a point or an exponent.  */
+      char c;
+      int num = 0;	/* number of tokens scanned by scanf */
+      char saved_char = p[len];
+
+      p[len] = 0;	/* null-terminate the token */
+      if (sizeof (putithere->typed_val_float.dval) <= sizeof (float))
+	num = sscanf (p, "%g%c", (float *) &putithere->typed_val_float.dval,&c);
+      else if (sizeof (putithere->typed_val_float.dval) <= sizeof (double))
+	num = sscanf (p, "%lg%c", (double *) &putithere->typed_val_float.dval,&c);
+      else
+	{
+#ifdef SCANF_HAS_LONG_DOUBLE
+	  num = sscanf (p, "%Lg%c", &putithere->typed_val_float.dval,&c);
+#else
+	  /* Scan it into a double, then assign it to the long double.
+	     This at least wins with values representable in the range
+	     of doubles. */
+	  double temp;
+	  num = sscanf (p, "%lg%c", &temp,&c);
+	  putithere->typed_val_float.dval = temp;
+#endif
+	}
+      p[len] = saved_char;	/* restore the input stream */
+      if (num != 1) 		/* check scanf found ONLY a float ... */
+	return ERROR;
+      /* See if it has `f' or `l' suffix (float or long double).  */
+
+      c = tolower (p[len - 1]);
+
+      if (c == 'f')
+	putithere->typed_val_float.type = builtin_type_float;
+      else if (c == 'l')
+	putithere->typed_val_float.type = builtin_type_long_double;
+      else if (isdigit (c) || c == '.')
+	putithere->typed_val_float.type = builtin_type_double;
+      else
+	return ERROR;
+
+      return FLOAT;
+    }
+
+  /* Handle base-switching prefixes 0x, 0t, 0d, 0 */
+  if (p[0] == '0')
+    switch (p[1])
+      {
+      case 'x':
+      case 'X':
+	if (len >= 3)
+	  {
+	    p += 2;
+	    base = 16;
+	    len -= 2;
+	  }
+	break;
+
+      case 't':
+      case 'T':
+      case 'd':
+      case 'D':
+	if (len >= 3)
+	  {
+	    p += 2;
+	    base = 10;
+	    len -= 2;
+	  }
+	break;
+
+      default:
+	base = 8;
+	break;
+      }
+
+  while (len-- > 0)
+    {
+      c = *p++;
+      if (c >= 'A' && c <= 'Z')
+	c += 'a' - 'A';
+      if (c != 'l' && c != 'u')
+	n *= base;
+      if (c >= '0' && c <= '9')
+	{
+	  if (found_suffix)
+	    return ERROR;
+	  n += i = c - '0';
+	}
+      else
+	{
+	  if (base > 10 && c >= 'a' && c <= 'f')
+	    {
+	      if (found_suffix)
+		return ERROR;
+	      n += i = c - 'a' + 10;
+	    }
+	  else if (c == 'l')
+	    {
+	      ++long_p;
+	      found_suffix = 1;
+	    }
+	  else if (c == 'u')
+	    {
+	      unsigned_p = 1;
+	      found_suffix = 1;
+	    }
+	  else
+	    return ERROR;	/* Char not a digit */
+	}
+      if (i >= base)
+	return ERROR;		/* Invalid digit in this base */
+
+      /* Portably test for overflow (only works for nonzero values, so make
+	 a second check for zero).  FIXME: Can't we just make n and prevn
+	 unsigned and avoid this?  */
+      if (c != 'l' && c != 'u' && (prevn >= n) && n != 0)
+	unsigned_p = 1;		/* Try something unsigned */
+
+      /* Portably test for unsigned overflow.
+	 FIXME: This check is wrong; for example it doesn't find overflow
+	 on 0x123456789 when LONGEST is 32 bits.  */
+      if (c != 'l' && c != 'u' && n != 0)
+	{	
+	  if ((unsigned_p && (ULONGEST) prevn >= (ULONGEST) n))
+	    error ("Numeric constant too large.");
+	}
+      prevn = n;
+    }
+
+  /* An integer constant is an int, a long, or a long long.  An L
+     suffix forces it to be long; an LL suffix forces it to be long
+     long.  If not forced to a larger size, it gets the first type of
+     the above that it fits in.  To figure out whether it fits, we
+     shift it right and see whether anything remains.  Note that we
+     can't shift sizeof (LONGEST) * HOST_CHAR_BIT bits or more in one
+     operation, because many compilers will warn about such a shift
+     (which always produces a zero result).  Sometimes TARGET_INT_BIT
+     or TARGET_LONG_BIT will be that big, sometimes not.  To deal with
+     the case where it is we just always shift the value more than
+     once, with fewer bits each time.  */
+
+  un = (ULONGEST)n >> 2;
+  if (long_p == 0
+      && (un >> (TARGET_INT_BIT - 2)) == 0)
+    {
+      high_bit = ((ULONGEST)1) << (TARGET_INT_BIT-1);
+
+      /* A large decimal (not hex or octal) constant (between INT_MAX
+	 and UINT_MAX) is a long or unsigned long, according to ANSI,
+	 never an unsigned int, but this code treats it as unsigned
+	 int.  This probably should be fixed.  GCC gives a warning on
+	 such constants.  */
+
+      unsigned_type = builtin_type_unsigned_int;
+      signed_type = builtin_type_int;
+    }
+  else if (long_p <= 1
+	   && (un >> (TARGET_LONG_BIT - 2)) == 0)
+    {
+      high_bit = ((ULONGEST)1) << (TARGET_LONG_BIT-1);
+      unsigned_type = builtin_type_unsigned_long;
+      signed_type = builtin_type_long;
+    }
+  else
+    {
+      high_bit = (((ULONGEST)1)
+		  << (TARGET_LONG_LONG_BIT - 32 - 1)
+		  << 16
+		  << 16);
+      if (high_bit == 0)
+	/* A long long does not fit in a LONGEST.  */
+	high_bit =
+	  (ULONGEST)1 << (sizeof (LONGEST) * HOST_CHAR_BIT - 1);
+      unsigned_type = builtin_type_unsigned_long_long;
+      signed_type = builtin_type_long_long;
+    }
+
+   putithere->typed_val_int.val = n;
+
+   /* If the high bit of the worked out type is set then this number
+      has to be unsigned. */
+
+   if (unsigned_p || (n & high_bit))
+     {
+       putithere->typed_val_int.type = unsigned_type;
+     }
+   else
+     {
+       putithere->typed_val_int.type = signed_type;
+     }
+
+   return INT;
+}
+
+struct token
+{
+  char *operator;
+  int token;
+  enum exp_opcode opcode;
+};
+
+static const struct token tokentab3[] =
+  {
+    {"shr", RSH, BINOP_END},
+    {"shl", LSH, BINOP_END},
+    {"and", ANDAND, BINOP_END},
+    {"div", DIV, BINOP_END},
+    {"not", NOT, BINOP_END},
+    {"mod", MOD, BINOP_END},
+    {"inc", INCREMENT, BINOP_END},
+    {"dec", DECREMENT, BINOP_END},
+    {"xor", XOR, BINOP_END}
+  };
+
+static const struct token tokentab2[] =
+  {
+    {"or", OR, BINOP_END},
+    {"<>", NOTEQUAL, BINOP_END},
+    {"<=", LEQ, BINOP_END},
+    {">=", GEQ, BINOP_END},
+    {":=", ASSIGN, BINOP_END}
+  };
+
+/* Allocate uppercased var */
+/* make an uppercased copy of tokstart */
+static char * uptok (tokstart, namelen)
+  char *tokstart;
+  int namelen;
+{
+  int i;
+  char *uptokstart = (char *)malloc(namelen+1);
+  for (i = 0;i <= namelen;i++)
+    {
+      if ((tokstart[i]>='a' && tokstart[i]<='z'))
+        uptokstart[i] = tokstart[i]-('a'-'A');
+      else
+        uptokstart[i] = tokstart[i];
+    }
+  uptokstart[namelen]='\0';
+  return uptokstart;
+}
+/* Read one token, getting characters through lexptr.  */
+
+
+static int
+yylex ()
+{
+  int c;
+  int namelen;
+  unsigned int i;
+  char *tokstart;
+  char *uptokstart;
+  char *tokptr;
+  char *p;
+  int tempbufindex;
+  static char *tempbuf;
+  static int tempbufsize;
+
+ retry:
+
+  tokstart = lexptr;
+  /* See if it is a special token of length 3.  */
+  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)
+    if (STREQN (tokstart, tokentab3[i].operator, 3))
+      {
+	lexptr += 3;
+	yylval.opcode = tokentab3[i].opcode;
+	return tokentab3[i].token;
+      }
+
+  /* See if it is a special token of length 2.  */
+  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)
+    if (STREQN (tokstart, tokentab2[i].operator, 2))
+      {
+	lexptr += 2;
+	yylval.opcode = tokentab2[i].opcode;
+	return tokentab2[i].token;
+      }
+
+  switch (c = *tokstart)
+    {
+    case 0:
+      return 0;
+
+    case ' ':
+    case '\t':
+    case '\n':
+      lexptr++;
+      goto retry;
+
+    case '\'':
+      /* We either have a character constant ('0' or '\177' for example)
+	 or we have a quoted symbol reference ('foo(int,int)' in object pascal
+	 for example). */
+      lexptr++;
+      c = *lexptr++;
+      if (c == '\\')
+	c = parse_escape (&lexptr);
+      else if (c == '\'')
+	error ("Empty character constant.");
+
+      yylval.typed_val_int.val = c;
+      yylval.typed_val_int.type = builtin_type_char;
+
+      c = *lexptr++;
+      if (c != '\'')
+	{
+	  namelen = skip_quoted (tokstart) - tokstart;
+	  if (namelen > 2)
+	    {
+	      lexptr = tokstart + namelen;
+	      if (lexptr[-1] != '\'')
+		error ("Unmatched single quote.");
+	      namelen -= 2;
+              tokstart++;
+              uptokstart = uptok(tokstart,namelen);
+	      goto tryname;
+	    }
+	  error ("Invalid character constant.");
+	}
+      return INT;
+
+    case '(':
+      paren_depth++;
+      lexptr++;
+      return c;
+
+    case ')':
+      if (paren_depth == 0)
+	return 0;
+      paren_depth--;
+      lexptr++;
+      return c;
+
+    case ',':
+      if (comma_terminates && paren_depth == 0)
+	return 0;
+      lexptr++;
+      return c;
+
+    case '.':
+      /* Might be a floating point number.  */
+      if (lexptr[1] < '0' || lexptr[1] > '9')
+	goto symbol;		/* Nope, must be a symbol. */
+      /* FALL THRU into number case.  */
+
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+      {
+	/* It's a number.  */
+	int got_dot = 0, got_e = 0, toktype;
+	register char *p = tokstart;
+	int hex = input_radix > 10;
+
+	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
+	  {
+	    p += 2;
+	    hex = 1;
+	  }
+	else if (c == '0' && (p[1]=='t' || p[1]=='T' || p[1]=='d' || p[1]=='D'))
+	  {
+	    p += 2;
+	    hex = 0;
+	  }
+
+	for (;; ++p)
+	  {
+	    /* This test includes !hex because 'e' is a valid hex digit
+	       and thus does not indicate a floating point number when
+	       the radix is hex.  */
+	    if (!hex && !got_e && (*p == 'e' || *p == 'E'))
+	      got_dot = got_e = 1;
+	    /* This test does not include !hex, because a '.' always indicates
+	       a decimal floating point number regardless of the radix.  */
+	    else if (!got_dot && *p == '.')
+	      got_dot = 1;
+	    else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
+		     && (*p == '-' || *p == '+'))
+	      /* This is the sign of the exponent, not the end of the
+		 number.  */
+	      continue;
+	    /* We will take any letters or digits.  parse_number will
+	       complain if past the radix, or if L or U are not final.  */
+	    else if ((*p < '0' || *p > '9')
+		     && ((*p < 'a' || *p > 'z')
+				  && (*p < 'A' || *p > 'Z')))
+	      break;
+	  }
+	toktype = parse_number (tokstart, p - tokstart, got_dot|got_e, &yylval);
+        if (toktype == ERROR)
+	  {
+	    char *err_copy = (char *) alloca (p - tokstart + 1);
+
+	    memcpy (err_copy, tokstart, p - tokstart);
+	    err_copy[p - tokstart] = 0;
+	    error ("Invalid number \"%s\".", err_copy);
+	  }
+	lexptr = p;
+	return toktype;
+      }
+
+    case '+':
+    case '-':
+    case '*':
+    case '/':
+    case '|':
+    case '&':
+    case '^':
+    case '~':
+    case '!':
+    case '@':
+    case '<':
+    case '>':
+    case '[':
+    case ']':
+    case '?':
+    case ':':
+    case '=':
+    case '{':
+    case '}':
+    symbol:
+      lexptr++;
+      return c;
+
+    case '"':
+
+      /* Build the gdb internal form of the input string in tempbuf,
+	 translating any standard C escape forms seen.  Note that the
+	 buffer is null byte terminated *only* for the convenience of
+	 debugging gdb itself and printing the buffer contents when
+	 the buffer contains no embedded nulls.  Gdb does not depend
+	 upon the buffer being null byte terminated, it uses the length
+	 string instead.  This allows gdb to handle C strings (as well
+	 as strings in other languages) with embedded null bytes */
+
+      tokptr = ++tokstart;
+      tempbufindex = 0;
+
+      do {
+	/* Grow the static temp buffer if necessary, including allocating
+	   the first one on demand. */
+	if (tempbufindex + 1 >= tempbufsize)
+	  {
+	    tempbuf = (char *) realloc (tempbuf, tempbufsize += 64);
+	  }
+	switch (*tokptr)
+	  {
+	  case '\0':
+	  case '"':
+	    /* Do nothing, loop will terminate. */
+	    break;
+	  case '\\':
+	    tokptr++;
+	    c = parse_escape (&tokptr);
+	    if (c == -1)
+	      {
+		continue;
+	      }
+	    tempbuf[tempbufindex++] = c;
+	    break;
+	  default:
+	    tempbuf[tempbufindex++] = *tokptr++;
+	    break;
+	  }
+      } while ((*tokptr != '"') && (*tokptr != '\0'));
+      if (*tokptr++ != '"')
+	{
+	  error ("Unterminated string in expression.");
+	}
+      tempbuf[tempbufindex] = '\0';	/* See note above */
+      yylval.sval.ptr = tempbuf;
+      yylval.sval.length = tempbufindex;
+      lexptr = tokptr;
+      return (STRING);
+    }
+
+  if (!(c == '_' || c == '$'
+	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
+    /* We must have come across a bad character (e.g. ';').  */
+    error ("Invalid character '%c' in expression.", c);
+
+  /* It's a name.  See how long it is.  */
+  namelen = 0;
+  for (c = tokstart[namelen];
+       (c == '_' || c == '$' || (c >= '0' && c <= '9')
+	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '<');)
+    {
+      /* Template parameter lists are part of the name.
+	 FIXME: This mishandles `print $a<4&&$a>3'.  */
+      if (c == '<')
+	{
+	  int i = namelen;
+	  int nesting_level = 1;
+	  while (tokstart[++i])
+	    {
+	      if (tokstart[i] == '<')
+		nesting_level++;
+	      else if (tokstart[i] == '>')
+		{
+		  if (--nesting_level == 0)
+		    break;
+		}
+	    }
+	  if (tokstart[i] == '>')
+	    namelen = i;
+	  else
+	    break;
+	}
+
+      /* do NOT uppercase internals because of registers !!! */
+      c = tokstart[++namelen];
+    }
+
+  uptokstart = uptok(tokstart,namelen);
+
+  /* The token "if" terminates the expression and is NOT
+     removed from the input stream.  */
+  if (namelen == 2 && uptokstart[0] == 'I' && uptokstart[1] == 'F')
+    {
+      return 0;
+    }
+
+  lexptr += namelen;
+
+  tryname:
+
+  /* Catch specific keywords.  Should be done with a data structure.  */
+  switch (namelen)
+    {
+    case 6:
+      if (STREQ (uptokstart, "OBJECT"))
+	return CLASS;
+      if (STREQ (uptokstart, "RECORD"))
+	return STRUCT;
+      if (STREQ (uptokstart, "SIZEOF"))
+	return SIZEOF;
+      break;
+    case 5:
+      if (STREQ (uptokstart, "CLASS"))
+	return CLASS;
+      if (STREQ (uptokstart, "FALSE"))
+	{
+          yylval.lval = 0;
+          return FALSE;
+        }
+      break;
+    case 4:
+      if (STREQ (uptokstart, "TRUE"))
+	{
+          yylval.lval = 1;
+  	  return TRUE;
+        }
+      if (STREQ (uptokstart, "SELF"))
+        {
+          /* here we search for 'this' like
+             inserted in FPC stabs debug info */
+	  static const char this_name[] =
+				 { /* CPLUS_MARKER,*/ 't', 'h', 'i', 's', '\0' };
+
+	  if (lookup_symbol (this_name, expression_context_block,
+			     VAR_NAMESPACE, (int *) NULL,
+			     (struct symtab **) NULL))
+	    return THIS;
+	}
+      break;
+    default:
+      break;
+    }
+
+  yylval.sval.ptr = tokstart;
+  yylval.sval.length = namelen;
+
+  if (*tokstart == '$')
+    {
+      /* $ is the normal prefix for pascal hexadecimal values
+        but this conflicts with the GDB use for debugger variables
+        so in expression to enter hexadecimal values
+        we still need to use C syntax with 0xff  */
+      write_dollar_variable (yylval.sval);
+      return VARIABLE;
+    }
+
+  /* Use token-type BLOCKNAME for symbols that happen to be defined as
+     functions or symtabs.  If this is not so, then ...
+     Use token-type TYPENAME for symbols that happen to be defined
+     currently as names of types; NAME for other symbols.
+     The caller is not constrained to care about the distinction.  */
+  {
+    char *tmp = copy_name (yylval.sval);
+    struct symbol *sym;
+    int is_a_field_of_this = 0;
+    int hextype;
+
+    sym = lookup_symbol (tmp, expression_context_block,
+			 VAR_NAMESPACE,
+			 &is_a_field_of_this,
+			 (struct symtab **) NULL);
+    /* second chance uppercased ! */
+    if (!sym)
+      {
+       for (i = 0;i <= namelen;i++)
+         {
+           if ((tmp[i]>='a' && tmp[i]<='z'))
+             tmp[i] -= ('a'-'A');
+           /* I am not sure that copy_name gives excatly the same result ! */
+           if ((tokstart[i]>='a' && tokstart[i]<='z'))
+             tokstart[i] -= ('a'-'A');
+         }
+        sym = lookup_symbol (tmp, expression_context_block,
+			 VAR_NAMESPACE,
+			 &is_a_field_of_this,
+			 (struct symtab **) NULL);
+      }
+    /* Call lookup_symtab, not lookup_partial_symtab, in case there are
+       no psymtabs (coff, xcoff, or some future change to blow away the
+       psymtabs once once symbols are read).  */
+    if ((sym && SYMBOL_CLASS (sym) == LOC_BLOCK) ||
+        lookup_symtab (tmp))
+      {
+	yylval.ssym.sym = sym;
+	yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+	return BLOCKNAME;
+      }
+    if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
+        {
+#if 1
+	  /* Despite the following flaw, we need to keep this code enabled.
+	     Because we can get called from check_stub_method, if we don't
+	     handle nested types then it screws many operations in any
+	     program which uses nested types.  */
+	  /* In "A::x", if x is a member function of A and there happens
+	     to be a type (nested or not, since the stabs don't make that
+	     distinction) named x, then this code incorrectly thinks we
+	     are dealing with nested types rather than a member function.  */
+
+	  char *p;
+	  char *namestart;
+	  struct symbol *best_sym;
+
+	  /* Look ahead to detect nested types.  This probably should be
+	     done in the grammar, but trying seemed to introduce a lot
+	     of shift/reduce and reduce/reduce conflicts.  It's possible
+	     that it could be done, though.  Or perhaps a non-grammar, but
+	     less ad hoc, approach would work well.  */
+
+	  /* Since we do not currently have any way of distinguishing
+	     a nested type from a non-nested one (the stabs don't tell
+	     us whether a type is nested), we just ignore the
+	     containing type.  */
+
+	  p = lexptr;
+	  best_sym = sym;
+	  while (1)
+	    {
+	      /* Skip whitespace.  */
+	      while (*p == ' ' || *p == '\t' || *p == '\n')
+		++p;
+	      if (*p == ':' && p[1] == ':')
+		{
+		  /* Skip the `::'.  */
+		  p += 2;
+		  /* Skip whitespace.  */
+		  while (*p == ' ' || *p == '\t' || *p == '\n')
+		    ++p;
+		  namestart = p;
+		  while (*p == '_' || *p == '$' || (*p >= '0' && *p <= '9')
+			 || (*p >= 'a' && *p <= 'z')
+			 || (*p >= 'A' && *p <= 'Z'))
+		    ++p;
+		  if (p != namestart)
+		    {
+		      struct symbol *cur_sym;
+		      /* As big as the whole rest of the expression, which is
+			 at least big enough.  */
+		      char *ncopy = alloca (strlen (tmp)+strlen (namestart)+3);
+		      char *tmp1;
+
+		      tmp1 = ncopy;
+		      memcpy (tmp1, tmp, strlen (tmp));
+		      tmp1 += strlen (tmp);
+		      memcpy (tmp1, "::", 2);
+		      tmp1 += 2;
+		      memcpy (tmp1, namestart, p - namestart);
+		      tmp1[p - namestart] = '\0';
+		      cur_sym = lookup_symbol (ncopy, expression_context_block,
+					       VAR_NAMESPACE, (int *) NULL,
+					       (struct symtab **) NULL);
+		      if (cur_sym)
+			{
+			  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)
+			    {
+			      best_sym = cur_sym;
+			      lexptr = p;
+			    }
+			  else
+			    break;
+			}
+		      else
+			break;
+		    }
+		  else
+		    break;
+		}
+	      else
+		break;
+	    }
+
+	  yylval.tsym.type = SYMBOL_TYPE (best_sym);
+#else /* not 0 */
+	  yylval.tsym.type = SYMBOL_TYPE (sym);
+#endif /* not 0 */
+	  return TYPENAME;
+        }
+    if ((yylval.tsym.type = lookup_primitive_typename (tmp)) != 0)
+	return TYPENAME;
+
+    /* Input names that aren't symbols but ARE valid hex numbers,
+       when the input radix permits them, can be names or numbers
+       depending on the parse.  Note we support radixes > 16 here.  */
+    if (!sym &&
+        ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10) ||
+         (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10)))
+      {
+ 	YYSTYPE newlval;	/* Its value is ignored.  */
+	hextype = parse_number (tokstart, namelen, 0, &newlval);
+	if (hextype == INT)
+	  {
+	    yylval.ssym.sym = sym;
+	    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+	    return NAME_OR_INT;
+	  }
+      }
+
+    free(uptokstart);
+    /* Any other kind of symbol */
+    yylval.ssym.sym = sym;
+    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
+    return NAME;
+  }
+}
+
+void
+yyerror (msg)
+     char *msg;
+{
+  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
+}
+
diff -urN origdb/p-lang.c gdb/p-lang.c
--- origdb/p-lang.c	Thu Jan  1 00:00:00 1970
+++ gdb/p-lang.c	Fri Nov  3 11:48:30 2000
@@ -0,0 +1,416 @@
+/* Pascal language support routines for GDB, the GNU debugger.
+   Copyright 2000 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file is derived from p-lang.c */
+
+#include "defs.h"
+#include "symtab.h"
+#include "gdbtypes.h"
+#include "expression.h"
+#include "parser-defs.h"
+#include "language.h"
+#include "p-lang.h"
+#include "valprint.h"
+
+extern void _initialize_pascal_language (void);
+static void pascal_one_char (int, struct ui_file *, int *);
+
+/* Print the character C on STREAM as part of the contents of a literal
+   string.
+   In_quotes is reset to 0 if a char is written with #4 notation */
+
+static void
+pascal_one_char (register int c, struct ui_file *stream, int *in_quotes)
+{
+
+  c &= 0xFF;			/* Avoid sign bit follies */
+
+  if ((c == '\'') || (PRINT_LITERAL_FORM (c)))
+    {
+      if (!(*in_quotes))
+	fputs_filtered ("'", stream);
+      *in_quotes = 1;
+      if (c == '\'')
+	{
+	  fputs_filtered ("''", stream);
+	}
+      else
+	fprintf_filtered (stream, "%c", c);
+    }
+  else
+    {
+      if (*in_quotes)
+	fputs_filtered ("'", stream);
+      *in_quotes = 0;
+      fprintf_filtered (stream, "#%d", (unsigned int) c);
+    }
+}
+
+static void pascal_emit_char (int c, struct ui_file *stream, int quoter);
+
+/* Print the character C on STREAM as part of the contents of a literal
+   string whose delimiter is QUOTER.  Note that that format for printing
+   characters and strings is language specific. */
+
+static void
+pascal_emit_char (register int c, struct ui_file *stream, int quoter)
+{
+  int in_quotes = 0;
+  pascal_one_char (c, stream, &in_quotes);
+  if (in_quotes)
+    fputs_filtered ("'", stream);
+}
+
+void
+pascal_printchar (int c, struct ui_file *stream)
+{
+  int in_quotes = 0;
+  pascal_one_char (c, stream, &in_quotes);
+  if (in_quotes)
+    fputs_filtered ("'", stream);
+}
+
+/* Print the character string STRING, printing at most LENGTH characters.
+   Printing stops early if the number hits print_max; repeat counts
+   are printed as appropriate.  Print ellipses at the end if we
+   had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.  */
+
+void
+pascal_printstr (struct ui_file *stream, char *string, unsigned int length,
+		 int width, int force_ellipses)
+{
+  register unsigned int i;
+  unsigned int things_printed = 0;
+  int in_quotes = 0;
+  int need_comma = 0;
+  extern int inspect_it;
+
+  /* If the string was not truncated due to `set print elements', and
+     the last byte of it is a null, we don't print that, in traditional C
+     style.  */
+  if ((!force_ellipses) && length > 0 && string[length - 1] == '\0')
+    length--;
+
+  if (length == 0)
+    {
+      fputs_filtered ("''", stream);
+      return;
+    }
+
+  for (i = 0; i < length && things_printed < print_max; ++i)
+    {
+      /* Position of the character we are examining
+         to see whether it is repeated.  */
+      unsigned int rep1;
+      /* Number of repetitions we have detected so far.  */
+      unsigned int reps;
+
+      QUIT;
+
+      if (need_comma)
+	{
+	  fputs_filtered (", ", stream);
+	  need_comma = 0;
+	}
+
+      rep1 = i + 1;
+      reps = 1;
+      while (rep1 < length && string[rep1] == string[i])
+	{
+	  ++rep1;
+	  ++reps;
+	}
+
+      if (reps > repeat_count_threshold)
+	{
+	  if (in_quotes)
+	    {
+	      if (inspect_it)
+		fputs_filtered ("\\', ", stream);
+	      else
+		fputs_filtered ("', ", stream);
+	      in_quotes = 0;
+	    }
+	  pascal_printchar (string[i], stream);
+	  fprintf_filtered (stream, " <repeats %u times>", reps);
+	  i = rep1 - 1;
+	  things_printed += repeat_count_threshold;
+	  need_comma = 1;
+	}
+      else
+	{
+	  int c = string[i];
+	  if ((!in_quotes) && (PRINT_LITERAL_FORM (c)))
+	    {
+	      if (inspect_it)
+		fputs_filtered ("\\'", stream);
+	      else
+		fputs_filtered ("'", stream);
+	      in_quotes = 1;
+	    }
+	  pascal_one_char (c, stream, &in_quotes);
+	  ++things_printed;
+	}
+    }
+
+  /* Terminate the quotes if necessary.  */
+  if (in_quotes)
+    {
+      if (inspect_it)
+	fputs_filtered ("\\'", stream);
+      else
+	fputs_filtered ("'", stream);
+    }
+
+  if (force_ellipses || i < length)
+    fputs_filtered ("...", stream);
+}
+
+/* Create a fundamental Pascal type using default reasonable for the current
+   target machine.
+
+   Some object/debugging file formats (DWARF version 1, COFF, etc) do not
+   define fundamental types such as "int" or "double".  Others (stabs or
+   DWARF version 2, etc) do define fundamental types.  For the formats which
+   don't provide fundamental types, gdb can create such types using this
+   function.
+
+   FIXME:  Some compilers distinguish explicitly signed integral types
+   (signed short, signed int, signed long) from "regular" integral types
+   (short, int, long) in the debugging information.  There is some dis-
+   agreement as to how useful this feature is.  In particular, gcc does
+   not support this.  Also, only some debugging formats allow the
+   distinction to be passed on to a debugger.  For now, we always just
+   use "short", "int", or "long" as the type name, for both the implicit
+   and explicitly signed types.  This also makes life easier for the
+   gdb test suite since we don't have to account for the differences
+   in output depending upon what the compiler and debugging format
+   support.  We will probably have to re-examine the issue when gdb
+   starts taking it's fundamental type information directly from the
+   debugging information supplied by the compiler.  fnf@cygnus.com */
+
+/* Note there might be some discussion about the choosen correspondance
+   because it mainly reflects Free Pascal Compiler setup for now PM */
+
+
+struct type *
+pascal_create_fundamental_type (struct objfile *objfile, int typeid)
+{
+  register struct type *type = NULL;
+
+  switch (typeid)
+    {
+    default:
+      /* FIXME:  For now, if we are asked to produce a type not in this
+         language, create the equivalent of a C integer type with the
+         name "<?type?>".  When all the dust settles from the type
+         reconstruction work, this should probably become an error. */
+      type = init_type (TYPE_CODE_INT,
+			TARGET_INT_BIT / TARGET_CHAR_BIT,
+			0, "<?type?>", objfile);
+      warning ("internal error: no Pascal fundamental type %d", typeid);
+      break;
+    case FT_VOID:
+      type = init_type (TYPE_CODE_VOID,
+			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
+			0, "void", objfile);
+      break;
+    case FT_CHAR:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
+			0, "char", objfile);
+      break;
+    case FT_SIGNED_CHAR:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
+			0, "shortint", objfile);
+      break;
+    case FT_UNSIGNED_CHAR:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_CHAR_BIT / TARGET_CHAR_BIT,
+			TYPE_FLAG_UNSIGNED, "byte", objfile);
+      break;
+    case FT_SHORT:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
+			0, "integer", objfile);
+      break;
+    case FT_SIGNED_SHORT:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
+			0, "integer", objfile);		/* FIXME-fnf */
+      break;
+    case FT_UNSIGNED_SHORT:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_SHORT_BIT / TARGET_CHAR_BIT,
+			TYPE_FLAG_UNSIGNED, "word", objfile);
+      break;
+    case FT_INTEGER:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_INT_BIT / TARGET_CHAR_BIT,
+			0, "longint", objfile);
+      break;
+    case FT_SIGNED_INTEGER:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_INT_BIT / TARGET_CHAR_BIT,
+			0, "longint", objfile);		/* FIXME -fnf */
+      break;
+    case FT_UNSIGNED_INTEGER:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_INT_BIT / TARGET_CHAR_BIT,
+			TYPE_FLAG_UNSIGNED, "cardinal", objfile);
+      break;
+    case FT_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_BIT / TARGET_CHAR_BIT,
+			0, "long", objfile);
+      break;
+    case FT_SIGNED_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_BIT / TARGET_CHAR_BIT,
+			0, "long", objfile);	/* FIXME -fnf */
+      break;
+    case FT_UNSIGNED_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_BIT / TARGET_CHAR_BIT,
+			TYPE_FLAG_UNSIGNED, "unsigned long", objfile);
+      break;
+    case FT_LONG_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
+			0, "long long", objfile);
+      break;
+    case FT_SIGNED_LONG_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
+			0, "signed long long", objfile);
+      break;
+    case FT_UNSIGNED_LONG_LONG:
+      type = init_type (TYPE_CODE_INT,
+			TARGET_LONG_LONG_BIT / TARGET_CHAR_BIT,
+			TYPE_FLAG_UNSIGNED, "unsigned long long", objfile);
+      break;
+    case FT_FLOAT:
+      type = init_type (TYPE_CODE_FLT,
+			TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
+			0, "float", objfile);
+      break;
+    case FT_DBL_PREC_FLOAT:
+      type = init_type (TYPE_CODE_FLT,
+			TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
+			0, "double", objfile);
+      break;
+    case FT_EXT_PREC_FLOAT:
+      type = init_type (TYPE_CODE_FLT,
+			TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT,
+			0, "extended", objfile);
+      break;
+    }
+  return (type);
+}
+
+
+/* Table mapping opcodes into strings for printing operators
+   and precedences of the operators.  */
+
+const struct op_print pascal_op_print_tab[] =
+{
+  {",", BINOP_COMMA, PREC_COMMA, 0},
+  {":=", BINOP_ASSIGN, PREC_ASSIGN, 1},
+  {"or", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},
+  {"xor", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},
+  {"and", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},
+  {"=", BINOP_EQUAL, PREC_EQUAL, 0},
+  {"<>", BINOP_NOTEQUAL, PREC_EQUAL, 0},
+  {"<=", BINOP_LEQ, PREC_ORDER, 0},
+  {">=", BINOP_GEQ, PREC_ORDER, 0},
+  {">", BINOP_GTR, PREC_ORDER, 0},
+  {"<", BINOP_LESS, PREC_ORDER, 0},
+  {"shr", BINOP_RSH, PREC_SHIFT, 0},
+  {"shl", BINOP_LSH, PREC_SHIFT, 0},
+  {"+", BINOP_ADD, PREC_ADD, 0},
+  {"-", BINOP_SUB, PREC_ADD, 0},
+  {"*", BINOP_MUL, PREC_MUL, 0},
+  {"/", BINOP_DIV, PREC_MUL, 0},
+  {"div", BINOP_INTDIV, PREC_MUL, 0},
+  {"mod", BINOP_REM, PREC_MUL, 0},
+  {"@", BINOP_REPEAT, PREC_REPEAT, 0},
+  {"-", UNOP_NEG, PREC_PREFIX, 0},
+  {"not", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},
+  {"^", UNOP_IND, PREC_SUFFIX, 1},
+  {"@", UNOP_ADDR, PREC_PREFIX, 0},
+  {"sizeof", UNOP_SIZEOF, PREC_PREFIX, 0},
+  {NULL, 0, 0, 0}
+};
+
+struct type **const /* CONST_PTR v 4.17 */ (pascal_builtin_types[]) =
+{
+  &builtin_type_int,
+    &builtin_type_long,
+    &builtin_type_short,
+    &builtin_type_char,
+    &builtin_type_float,
+    &builtin_type_double,
+    &builtin_type_void,
+    &builtin_type_long_long,
+    &builtin_type_signed_char,
+    &builtin_type_unsigned_char,
+    &builtin_type_unsigned_short,
+    &builtin_type_unsigned_int,
+    &builtin_type_unsigned_long,
+    &builtin_type_unsigned_long_long,
+    &builtin_type_long_double,
+    &builtin_type_complex,
+    &builtin_type_double_complex,
+    0
+};
+
+const struct language_defn pascal_language_defn =
+{
+  "pascal",			/* Language name */
+  language_pascal,
+  pascal_builtin_types,
+  range_check_on,
+  type_check_on,
+  pascal_parse,
+  pascal_error,
+  evaluate_subexp_standard,
+  pascal_printchar,		/* Print a character constant */
+  pascal_printstr,		/* Function to print string constant */
+  pascal_emit_char,		/* Print a single char */
+  pascal_create_fundamental_type,	/* Create fundamental type in this language */
+  pascal_print_type,		/* Print a type using appropriate syntax */
+  pascal_val_print,		/* Print a value using appropriate syntax */
+  pascal_value_print,		/* Print a top-level value */
+  {"", "%", "b", ""},		/* Binary format info */
+  {"0%lo", "0", "o", ""},	/* Octal format info */
+  {"%ld", "", "d", ""},		/* Decimal format info */
+  {"$%lx", "$", "x", ""},	/* Hex format info */
+  pascal_op_print_tab,		/* expression operators for printing */
+  1,				/* c-style arrays */
+  0,				/* String lower bound */
+  &builtin_type_char,		/* Type of string elements */
+  LANG_MAGIC
+};
+
+void
+_initialize_pascal_language (void)
+{
+  add_language (&pascal_language_defn);
+}
diff -urN origdb/p-lang.h gdb/p-lang.h
--- origdb/p-lang.h	Thu Jan  1 00:00:00 1970
+++ gdb/p-lang.h	Fri Nov  3 11:57:12 2000
@@ -0,0 +1,102 @@
+/* C language support definitions for GDB, the GNU debugger.
+   Copyright 1992, 1996 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifdef __STDC__			/* Forward decls for prototypes */
+struct value;
+#endif
+
+extern int
+pascal_parse PARAMS ((void));	/* Defined in p-exp.y */
+
+extern void
+pascal_error PARAMS ((char *));	/* Defined in p-exp.y */
+
+extern void			/* Defined in p-typeprint.c */
+pascal_print_type PARAMS ((struct type *, char *, struct ui_file *, int, int));
+
+extern int
+pascal_val_print PARAMS ((struct type *, char *, int, CORE_ADDR, struct ui_file *, int, int,
+		       int, enum val_prettyprint));
+
+extern int
+pascal_value_print PARAMS ((struct value *, struct ui_file *, int, enum val_prettyprint));
+
+extern void
+pascal_type_print_method_args PARAMS ((char *, char *,
+				    struct ui_file *));
+
+/* These are in p-lang.c: */
+
+extern void pascal_printchar PARAMS ((int, struct ui_file *));
+
+extern void pascal_printstr PARAMS ((struct ui_file *, char *, unsigned int, int, int));
+
+extern struct type *pascal_create_fundamental_type PARAMS ((struct objfile *, int));
+
+extern struct type **const (pascal_builtin_types[]);
+/* extern struct type ** const (c_builtin_types[]); */
+
+/* These are in p-typeprint.c: */
+
+extern void
+pascal_type_print_base PARAMS ((struct type *, struct ui_file *, int, int));
+
+extern void
+pascal_type_print_varspec_prefix PARAMS ((struct type *, struct ui_file *, int, int));
+
+/* These are in cp-valprint.c */
+
+extern int vtblprint;		/* Controls printing of vtbl's */
+
+extern int static_field_print;
+
+extern void
+pascal_cp_print_class_member PARAMS ((char *, struct type *, struct ui_file *, char *));
+
+extern void
+pascal_cp_print_class_method PARAMS ((char *, struct type *, struct ui_file *));
+
+extern void
+pascal_cp_print_value_fields PARAMS ((struct type *, char *, CORE_ADDR,
+			   struct ui_file *, int, int, enum val_prettyprint,
+				   struct type **, int));
+
+extern int
+pascal_cp_is_vtbl_ptr_type PARAMS ((struct type *));
+
+extern int
+pascal_cp_is_vtbl_member PARAMS ((struct type *));
+
+extern void
+pascal_object_print_class_method PARAMS ((char *, struct type *,
+				  struct ui_file *));
+
+extern void
+pascal_object_print_value_fields PARAMS ((struct type *, char *,
+				  CORE_ADDR, struct ui_file *,
+				  int, int,
+				  enum val_prettyprint,
+				  struct type **,
+				  int));
+
+extern void
+pascal_object_print_class_member PARAMS ((char *, struct type *,
+				  struct ui_file *, char *));
+
+
diff -urN origdb/p-typeprint.c gdb/p-typeprint.c
--- origdb/p-typeprint.c	Thu Jan  1 00:00:00 1970
+++ gdb/p-typeprint.c	Fri Nov  3 11:26:00 2000
@@ -0,0 +1,861 @@
+/* Support for printing Pascal types for GDB, the GNU debugger.
+   Copyright 2000
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file is derived from p-typeprint.c */
+
+#include "defs.h"
+#include "obstack.h"
+#include "bfd.h"		/* Binary File Description */
+#include "symtab.h"
+#include "gdbtypes.h"
+#include "expression.h"
+#include "value.h"
+#include "gdbcore.h"
+#include "target.h"
+#include "command.h"
+#include "gdbcmd.h"
+#include "language.h"
+#include "demangle.h"
+#include "p-lang.h"
+#include "typeprint.h"
+
+#include "gdb_string.h"
+#include <errno.h>
+#include <ctype.h>
+
+static void pascal_type_print_args (struct type *, struct ui_file *);
+
+static void pascal_type_print_varspec_suffix (struct type *, struct ui_file *, int, int, int);
+
+static void pascal_type_print_derivation_info (struct ui_file *, struct type *);
+
+void pascal_type_print_varspec_prefix (struct type *, struct ui_file *, int, int);
+
+
+/* LEVEL is the depth to indent lines by.  */
+
+void
+pascal_print_type (struct type *type, char *varstring, struct ui_file *stream,
+		   int show, int level)
+{
+  register enum type_code code;
+  int demangled_args;
+
+  code = TYPE_CODE (type);
+
+  if (show > 0)
+    CHECK_TYPEDEF (type);
+
+  if ((code == TYPE_CODE_FUNC ||
+       code == TYPE_CODE_METHOD))
+    {
+      pascal_type_print_varspec_prefix (type, stream, show, 0);
+    }
+  /* first the name */
+  fputs_filtered (varstring, stream);
+
+  if ((varstring != NULL && *varstring != '\0') &&
+      !(code == TYPE_CODE_FUNC ||
+	code == TYPE_CODE_METHOD))
+    {
+      fputs_filtered (" : ", stream);
+    }
+
+  if (!(code == TYPE_CODE_FUNC ||
+	code == TYPE_CODE_METHOD))
+    {
+      pascal_type_print_varspec_prefix (type, stream, show, 0);
+    }
+
+  pascal_type_print_base (type, stream, show, level);
+  /* For demangled function names, we have the arglist as part of the name,
+     so don't print an additional pair of ()'s */
+
+  demangled_args = varstring ? strchr (varstring, '(') != NULL : 0;
+  pascal_type_print_varspec_suffix (type, stream, show, 0, demangled_args);
+
+}
+
+/* If TYPE is a derived type, then print out derivation information.
+   Print only the actual base classes of this type, not the base classes
+   of the base classes.  I.E.  for the derivation hierarchy:
+
+   class A { int a; };
+   class B : public A {int b; };
+   class C : public B {int c; };
+
+   Print the type of class C as:
+
+   class C : public B {
+   int c;
+   }
+
+   Not as the following (like gdb used to), which is not legal C++ syntax for
+   derived types and may be confused with the multiple inheritance form:
+
+   class C : public B : public A {
+   int c;
+   }
+
+   In general, gdb should try to print the types as closely as possible to
+   the form that they appear in the source code. */
+
+static void
+pascal_type_print_derivation_info (struct ui_file *stream, struct type *type)
+{
+  char *name;
+  int i;
+
+  for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
+    {
+      fputs_filtered (i == 0 ? ": " : ", ", stream);
+      fprintf_filtered (stream, "%s%s ",
+			BASETYPE_VIA_PUBLIC (type, i) ? "public" : "private",
+			BASETYPE_VIA_VIRTUAL (type, i) ? " virtual" : "");
+      name = type_name_no_tag (TYPE_BASECLASS (type, i));
+      fprintf_filtered (stream, "%s", name ? name : "(null)");
+    }
+  if (i > 0)
+    {
+      fputs_filtered (" ", stream);
+    }
+}
+
+/* Print the Pascal method arguments ARGS to the file STREAM.  */
+
+void
+pascal_type_print_method_args (char *physname, char *methodname,
+			       struct ui_file *stream)
+{
+  int is_constructor = STREQN (physname, "__ct__", 6);
+  int is_destructor = STREQN (physname, "__dt__", 6);
+
+  if (is_constructor || is_destructor)
+    {
+      physname += 6;
+    }
+
+  fputs_filtered (methodname, stream);
+
+  if (physname && (*physname != 0))
+    {
+      int i = 0;
+      int len = 0;
+      char storec;
+      char *argname;
+      fputs_filtered (" (", stream);
+      /* we must demangle this */
+      while (isdigit (physname[0]))
+	{
+	  while (isdigit (physname[len]))
+	    {
+	      len++;
+	    }
+	  i = strtol (physname, &argname, 0);
+	  physname += len;
+	  storec = physname[i];
+	  physname[i] = 0;
+	  fputs_filtered (physname, stream);
+	  physname[i] = storec;
+	  physname += i;
+	  if (physname[0] != 0)
+	    {
+	      fputs_filtered (", ", stream);
+	    }
+	}
+      fputs_filtered (")", stream);
+    }
+}
+
+/* Print any asterisks or open-parentheses needed before the
+   variable name (to describe its type).
+
+   On outermost call, pass 0 for PASSED_A_PTR.
+   On outermost call, SHOW > 0 means should ignore
+   any typename for TYPE and show its details.
+   SHOW is always zero on recursive calls.  */
+
+void
+pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,
+				  int show, int passed_a_ptr)
+{
+  char *name;
+  if (type == 0)
+    return;
+
+  if (TYPE_NAME (type) && show <= 0)
+    return;
+
+  QUIT;
+
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_PTR:
+      fprintf_filtered (stream, "^");
+      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1);
+      break;			/* pointer should be handled normally in pascal */
+
+    case TYPE_CODE_MEMBER:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, "(");
+      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
+      fprintf_filtered (stream, " ");
+      name = type_name_no_tag (TYPE_DOMAIN_TYPE (type));
+      if (name)
+	fputs_filtered (name, stream);
+      else
+	pascal_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
+      fprintf_filtered (stream, "::");
+      break;
+
+    case TYPE_CODE_METHOD:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, "(");
+      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
+	{
+	  fprintf_filtered (stream, "function  ");
+	}
+      else
+	{
+	  fprintf_filtered (stream, "procedure ");
+	}
+
+      if (passed_a_ptr)
+	{
+	  fprintf_filtered (stream, " ");
+	  pascal_type_print_base (TYPE_DOMAIN_TYPE (type), stream, 0, passed_a_ptr);
+	  fprintf_filtered (stream, "::");
+	}
+      break;
+
+    case TYPE_CODE_REF:
+      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1);
+      fprintf_filtered (stream, "&");
+      break;
+
+    case TYPE_CODE_FUNC:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, "(");
+
+      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
+	{
+	  fprintf_filtered (stream, "function  ");
+	}
+      else
+	{
+	  fprintf_filtered (stream, "procedure ");
+	}
+
+      break;
+
+    case TYPE_CODE_ARRAY:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, "(");
+      fprintf_filtered (stream, "array ");
+      if (TYPE_LENGTH (type) >= 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
+	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
+	fprintf_filtered (stream, "[%d..%d] ",
+			  TYPE_ARRAY_LOWER_BOUND_VALUE (type),
+			  TYPE_ARRAY_UPPER_BOUND_VALUE (type)
+	  );
+      fprintf_filtered (stream, "of ");
+      break;
+
+    case TYPE_CODE_UNDEF:
+    case TYPE_CODE_STRUCT:
+    case TYPE_CODE_UNION:
+    case TYPE_CODE_ENUM:
+    case TYPE_CODE_INT:
+    case TYPE_CODE_FLT:
+    case TYPE_CODE_VOID:
+    case TYPE_CODE_ERROR:
+    case TYPE_CODE_CHAR:
+    case TYPE_CODE_BOOL:
+    case TYPE_CODE_SET:
+    case TYPE_CODE_RANGE:
+    case TYPE_CODE_STRING:
+    case TYPE_CODE_BITSTRING:
+    case TYPE_CODE_COMPLEX:
+    case TYPE_CODE_TYPEDEF:
+    case TYPE_CODE_TEMPLATE:
+      /* These types need no prefix.  They are listed here so that
+         gcc -Wall will reveal any types that haven't been handled.  */
+      break;
+    default:
+      error ("type not handled in pascal_type_print_varspec_prefix()");
+      break;
+    }
+}
+
+static void
+pascal_type_print_args (struct type *type, struct ui_file *stream)
+{
+  int i;
+  struct type **args;
+
+  /*  fprintf_filtered (stream, "(");
+     no () for procedures !! */
+  args = TYPE_ARG_TYPES (type);
+  if (args != NULL)
+    {
+      if ((args[1] != NULL && args[1]->code != TYPE_CODE_VOID) ||
+	  (args[2] != NULL))
+	{
+	  fprintf_filtered (stream, "(");
+	}
+      if (args[1] == NULL)
+	{
+	  fprintf_filtered (stream, "...");
+	}
+      else
+	{
+	  for (i = 1;
+	       args[i] != NULL && args[i]->code != TYPE_CODE_VOID;
+	       i++)
+	    {
+	      pascal_print_type (args[i], "", stream, -1, 0);
+	      if (args[i + 1] == NULL)
+		{
+		  fprintf_filtered (stream, "...");
+		}
+	      else if (args[i + 1]->code != TYPE_CODE_VOID)
+		{
+		  fprintf_filtered (stream, ",");
+		  wrap_here ("    ");
+		}
+	    }
+	}
+      if ((args[1] != NULL && args[1]->code != TYPE_CODE_VOID) ||
+	  (args[2] != NULL))
+	{
+	  fprintf_filtered (stream, ")");
+	}
+    }
+}
+
+static void
+pascal_print_func_args (struct type *type, struct ui_file *stream)
+{
+  int i, len = TYPE_NFIELDS (type);
+  if (len)
+    {
+      fprintf_filtered (stream, "(");
+    }
+  for (i = 0; i < len; i++)
+    {
+      if (i > 0)
+	{
+	  fputs_filtered (", ", stream);
+	  wrap_here ("    ");
+	}
+      /*  can we find if it is a var parameter ??
+         if ( TYPE_FIELD(type, i) == )
+         {
+         fprintf_filtered (stream, "var ");
+         } */
+      pascal_print_type (TYPE_FIELD_TYPE (type, i), ""	/* TYPE_FIELD_NAME seems invalid ! */
+			 ,stream, -1, 0);
+    }
+  if (len)
+    {
+      fprintf_filtered (stream, ")");
+    }
+}
+
+/* Print any array sizes, function arguments or close parentheses
+   needed after the variable name (to describe its type).
+   Args work like pascal_type_print_varspec_prefix.  */
+
+static void
+pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,
+				  int show, int passed_a_ptr,
+				  int demangled_args)
+{
+  if (type == 0)
+    return;
+
+  if (TYPE_NAME (type) && show <= 0)
+    return;
+
+  QUIT;
+
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_ARRAY:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, ")");
+      break;
+
+    case TYPE_CODE_MEMBER:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, ")");
+      pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
+      break;
+
+    case TYPE_CODE_METHOD:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, ")");
+      pascal_type_print_method_args ("",
+				     "",
+				     stream);
+      /* pascal_type_print_args (type, stream); */
+      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
+	{
+	  fprintf_filtered (stream, " : ");
+	  pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
+	  pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, 0);
+	  pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,
+					    passed_a_ptr, 0);
+	}
+      break;
+
+    case TYPE_CODE_PTR:
+    case TYPE_CODE_REF:
+      pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 1, 0);
+      break;
+
+    case TYPE_CODE_FUNC:
+      if (passed_a_ptr)
+	fprintf_filtered (stream, ")");
+      if (!demangled_args)
+	pascal_print_func_args (type, stream);
+      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)
+	{
+	  fprintf_filtered (stream, " : ");
+	  pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
+	  pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, 0);
+	  pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,
+					    passed_a_ptr, 0);
+	}
+      break;
+
+    case TYPE_CODE_UNDEF:
+    case TYPE_CODE_STRUCT:
+    case TYPE_CODE_UNION:
+    case TYPE_CODE_ENUM:
+    case TYPE_CODE_INT:
+    case TYPE_CODE_FLT:
+    case TYPE_CODE_VOID:
+    case TYPE_CODE_ERROR:
+    case TYPE_CODE_CHAR:
+    case TYPE_CODE_BOOL:
+    case TYPE_CODE_SET:
+    case TYPE_CODE_RANGE:
+    case TYPE_CODE_STRING:
+    case TYPE_CODE_BITSTRING:
+    case TYPE_CODE_COMPLEX:
+    case TYPE_CODE_TYPEDEF:
+    case TYPE_CODE_TEMPLATE:
+      /* These types do not need a suffix.  They are listed so that
+         gcc -Wall will report types that may not have been considered.  */
+      break;
+    default:
+      error ("type not handled in pascal_type_print_varspec_suffix()");
+      break;
+    }
+}
+
+/* Print the name of the type (or the ultimate pointer target,
+   function value or array element), or the description of a
+   structure or union.
+
+   SHOW positive means print details about the type (e.g. enum values),
+   and print structure elements passing SHOW - 1 for show.
+   SHOW negative means just print the type name or struct tag if there is one.
+   If there is no name, print something sensible but concise like
+   "struct {...}".
+   SHOW zero means just print the type name or struct tag if there is one.
+   If there is no name, print something sensible but not as concise like
+   "struct {int x; int y;}".
+
+   LEVEL is the number of spaces to indent by.
+   We increase it for some recursive calls.  */
+
+void
+pascal_type_print_base (struct type *type, struct ui_file *stream, int show,
+			int level)
+{
+  register int i;
+  register int len;
+  register int lastval;
+  enum
+    {
+      s_none, s_public, s_private, s_protected
+    }
+  section_type;
+  QUIT;
+
+  wrap_here ("    ");
+  if (type == NULL)
+    {
+      fputs_filtered ("<type unknown>", stream);
+      return;
+    }
+
+  /* void pointer */
+  if ((TYPE_CODE (type) == TYPE_CODE_PTR) && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_VOID))
+    {
+      fprintf_filtered (stream,
+			TYPE_NAME (type) ? TYPE_NAME (type) : "pointer");
+      return;
+    }
+  /* When SHOW is zero or less, and there is a valid type name, then always
+     just print the type name directly from the type.  */
+
+  if (show <= 0
+      && TYPE_NAME (type) != NULL)
+    {
+      fputs_filtered (TYPE_NAME (type), stream);
+      return;
+    }
+
+  CHECK_TYPEDEF (type);
+
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_TYPEDEF:
+    case TYPE_CODE_PTR:
+    case TYPE_CODE_MEMBER:
+    case TYPE_CODE_REF:
+      /* case TYPE_CODE_FUNC:
+         case TYPE_CODE_METHOD: */
+      pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
+      break;
+
+    case TYPE_CODE_ARRAY:
+      /* pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 0);
+         pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
+         pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0); */
+      pascal_print_type (TYPE_TARGET_TYPE (type), NULL, stream, 0, 0);
+      break;
+
+    case TYPE_CODE_FUNC:
+    case TYPE_CODE_METHOD:
+      /*
+         pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);
+         only after args !! */
+      break;
+    case TYPE_CODE_STRUCT:
+      if (TYPE_TAG_NAME (type) != NULL)
+	{
+	  fputs_filtered (TYPE_TAG_NAME (type), stream);
+	  fputs_filtered (" = ", stream);
+	}
+      if (HAVE_CPLUS_STRUCT (type))
+	{
+	  fprintf_filtered (stream, "class ");
+	}
+      else
+	{
+	  fprintf_filtered (stream, "record ");
+	}
+      goto struct_union;
+
+    case TYPE_CODE_UNION:
+      if (TYPE_TAG_NAME (type) != NULL)
+	{
+	  fputs_filtered (TYPE_TAG_NAME (type), stream);
+	  fputs_filtered (" = ", stream);
+	}
+      fprintf_filtered (stream, "case <?> of ");
+
+    struct_union:
+      wrap_here ("    ");
+      if (show < 0)
+	{
+	  /* If we just printed a tag name, no need to print anything else.  */
+	  if (TYPE_TAG_NAME (type) == NULL)
+	    fprintf_filtered (stream, "{...}");
+	}
+      else if (show > 0 || TYPE_TAG_NAME (type) == NULL)
+	{
+	  pascal_type_print_derivation_info (stream, type);
+
+	  fprintf_filtered (stream, "\n");
+	  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))
+	    {
+	      if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
+		fprintfi_filtered (level + 4, stream, "<incomplete type>\n");
+	      else
+		fprintfi_filtered (level + 4, stream, "<no data fields>\n");
+	    }
+
+	  /* Start off with no specific section type, so we can print
+	     one for the first field we find, and use that section type
+	     thereafter until we find another type. */
+
+	  section_type = s_none;
+
+	  /* If there is a base class for this type,
+	     do not print the field that it occupies.  */
+
+	  len = TYPE_NFIELDS (type);
+	  for (i = TYPE_N_BASECLASSES (type); i < len; i++)
+	    {
+	      QUIT;
+	      /* Don't print out virtual function table.  */
+	      if (STREQN (TYPE_FIELD_NAME (type, i), "_vptr", 5)
+		  && is_cplus_marker ((TYPE_FIELD_NAME (type, i))[5]))
+		continue;
+
+	      /* If this is a pascal object or class we can print the
+	         various section labels. */
+
+	      if (HAVE_CPLUS_STRUCT (type))
+		{
+		  if (TYPE_FIELD_PROTECTED (type, i))
+		    {
+		      if (section_type != s_protected)
+			{
+			  section_type = s_protected;
+			  fprintfi_filtered (level + 2, stream,
+					     "protected\n");
+			}
+		    }
+		  else if (TYPE_FIELD_PRIVATE (type, i))
+		    {
+		      if (section_type != s_private)
+			{
+			  section_type = s_private;
+			  fprintfi_filtered (level + 2, stream, "private\n");
+			}
+		    }
+		  else
+		    {
+		      if (section_type != s_public)
+			{
+			  section_type = s_public;
+			  fprintfi_filtered (level + 2, stream, "public\n");
+			}
+		    }
+		}
+
+	      print_spaces_filtered (level + 4, stream);
+	      if (TYPE_FIELD_STATIC (type, i))
+		{
+		  fprintf_filtered (stream, "static ");
+		}
+	      pascal_print_type (TYPE_FIELD_TYPE (type, i),
+				 TYPE_FIELD_NAME (type, i),
+				 stream, show - 1, level + 4);
+	      if (!TYPE_FIELD_STATIC (type, i)
+		  && TYPE_FIELD_PACKED (type, i))
+		{
+		  /* It is a bitfield.  This code does not attempt
+		     to look at the bitpos and reconstruct filler,
+		     unnamed fields.  This would lead to misleading
+		     results if the compiler does not put out fields
+		     for such things (I don't know what it does).  */
+		  fprintf_filtered (stream, " : %d",
+				    TYPE_FIELD_BITSIZE (type, i));
+		}
+	      fprintf_filtered (stream, ";\n");
+	    }
+
+	  /* If there are both fields and methods, put a space between. */
+	  len = TYPE_NFN_FIELDS (type);
+	  if (len && section_type != s_none)
+	    fprintf_filtered (stream, "\n");
+
+	  /* Pbject pascal: print out the methods */
+
+	  for (i = 0; i < len; i++)
+	    {
+	      struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);
+	      int j, len2 = TYPE_FN_FIELDLIST_LENGTH (type, i);
+	      char *method_name = TYPE_FN_FIELDLIST_NAME (type, i);
+	      char *name = type_name_no_tag (type);
+	      /* this is GNU C++ specific
+	         how can we know constructor/destructor?
+	         It might work for GNU pascal */
+	      for (j = 0; j < len2; j++)
+		{
+		  char *physname = TYPE_FN_FIELD_PHYSNAME (f, j);
+
+		  int is_constructor = STREQN (physname, "__ct__", 6);
+		  int is_destructor = STREQN (physname, "__dt__", 6);
+
+		  QUIT;
+		  if (TYPE_FN_FIELD_PROTECTED (f, j))
+		    {
+		      if (section_type != s_protected)
+			{
+			  section_type = s_protected;
+			  fprintfi_filtered (level + 2, stream,
+					     "protected\n");
+			}
+		    }
+		  else if (TYPE_FN_FIELD_PRIVATE (f, j))
+		    {
+		      if (section_type != s_private)
+			{
+			  section_type = s_private;
+			  fprintfi_filtered (level + 2, stream, "private\n");
+			}
+		    }
+		  else
+		    {
+		      if (section_type != s_public)
+			{
+			  section_type = s_public;
+			  fprintfi_filtered (level + 2, stream, "public\n");
+			}
+		    }
+
+		  print_spaces_filtered (level + 4, stream);
+		  if (TYPE_FN_FIELD_STATIC_P (f, j))
+		    fprintf_filtered (stream, "static ");
+		  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) == 0)
+		    {
+		      /* Keep GDB from crashing here.  */
+		      fprintf_filtered (stream, "<undefined type> %s;\n",
+					TYPE_FN_FIELD_PHYSNAME (f, j));
+		      break;
+		    }
+
+		  if (is_constructor)
+		    {
+		      fprintf_filtered (stream, "constructor ");
+		    }
+		  else if (is_destructor)
+		    {
+		      fprintf_filtered (stream, "destructor  ");
+		    }
+		  else if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) != 0 &&
+			   TYPE_CODE (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j))) != TYPE_CODE_VOID)
+		    {
+		      fprintf_filtered (stream, "function  ");
+		    }
+		  else
+		    {
+		      fprintf_filtered (stream, "procedure ");
+		    }
+		  /* this does not work, no idea why !! */
+
+		  pascal_type_print_method_args (physname,
+						 method_name,
+						 stream);
+
+		  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) != 0 &&
+		      TYPE_CODE (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j))) != TYPE_CODE_VOID)
+		    {
+		      fputs_filtered (" : ", stream);
+		      type_print (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)),
+				  "", stream, -1);
+		    }
+		  if (TYPE_FN_FIELD_VIRTUAL_P (f, j))
+		    fprintf_filtered (stream, "; virtual");
+
+		  fprintf_filtered (stream, ";\n");
+		}
+	    }
+	  fprintfi_filtered (level, stream, "end");
+	}
+      break;
+
+    case TYPE_CODE_ENUM:
+      if (TYPE_TAG_NAME (type) != NULL)
+	{
+	  fputs_filtered (TYPE_TAG_NAME (type), stream);
+	  if (show > 0)
+	    fputs_filtered (" ", stream);
+	}
+      /* enum is just defined by
+         type enume_name = (enum_member1,enum_member2,...) */
+      fprintf_filtered (stream, " = ");
+      wrap_here ("    ");
+      if (show < 0)
+	{
+	  /* If we just printed a tag name, no need to print anything else.  */
+	  if (TYPE_TAG_NAME (type) == NULL)
+	    fprintf_filtered (stream, "(...)");
+	}
+      else if (show > 0 || TYPE_TAG_NAME (type) == NULL)
+	{
+	  fprintf_filtered (stream, "(");
+	  len = TYPE_NFIELDS (type);
+	  lastval = 0;
+	  for (i = 0; i < len; i++)
+	    {
+	      QUIT;
+	      if (i)
+		fprintf_filtered (stream, ", ");
+	      wrap_here ("    ");
+	      fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
+	      if (lastval != TYPE_FIELD_BITPOS (type, i))
+		{
+		  fprintf_filtered (stream, " := %d", TYPE_FIELD_BITPOS (type, i));
+		  lastval = TYPE_FIELD_BITPOS (type, i);
+		}
+	      lastval++;
+	    }
+	  fprintf_filtered (stream, ")");
+	}
+      break;
+
+    case TYPE_CODE_VOID:
+      fprintf_filtered (stream, "void");
+      break;
+
+    case TYPE_CODE_UNDEF:
+      fprintf_filtered (stream, "record <unknown>");
+      break;
+
+    case TYPE_CODE_ERROR:
+      fprintf_filtered (stream, "<unknown type>");
+      break;
+
+      /* this probably does not work for enums */
+    case TYPE_CODE_RANGE:
+      {
+	struct type *target = TYPE_TARGET_TYPE (type);
+	if (target == NULL)
+	  target = builtin_type_long;
+	print_type_scalar (target, TYPE_LOW_BOUND (type), stream);
+	fputs_filtered ("..", stream);
+	print_type_scalar (target, TYPE_HIGH_BOUND (type), stream);
+      }
+      break;
+
+    case TYPE_CODE_SET:
+      fputs_filtered ("set of ", stream);
+      pascal_print_type (TYPE_INDEX_TYPE (type), "", stream,
+			 show - 1, level);
+      break;
+
+    default:
+      /* Handle types not explicitly handled by the other cases,
+         such as fundamental types.  For these, just print whatever
+         the type name is, as recorded in the type itself.  If there
+         is no type name, then complain. */
+      if (TYPE_NAME (type) != NULL)
+	{
+	  fputs_filtered (TYPE_NAME (type), stream);
+	}
+      else
+	{
+	  /* At least for dump_symtab, it is important that this not be
+	     an error ().  */
+	  fprintf_filtered (stream, "<invalid unnamed pascal type code %d>",
+			    TYPE_CODE (type));
+	}
+      break;
+    }
+}
diff -urN origdb/p-valprint.c gdb/p-valprint.c
--- origdb/p-valprint.c	Thu Jan  1 00:00:00 1970
+++ gdb/p-valprint.c	Fri Nov  3 11:26:00 2000
@@ -0,0 +1,1142 @@
+/* Support for printing Pascal values for GDB, the GNU debugger.
+   Copyright 2000
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file is derived from c-valprint.c */
+
+#include "defs.h"
+#include "obstack.h"
+#include "symtab.h"
+#include "gdbtypes.h"
+#include "expression.h"
+#include "value.h"
+#include "command.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "demangle.h"
+#include "valprint.h"
+#include "language.h"
+#include "target.h"
+#include "annotate.h"
+#include "p-lang.h"
+
+
+
+
+/* Print data of type TYPE located at VALADDR (within GDB), which came from
+   the inferior at address ADDRESS, onto stdio stream STREAM according to
+   FORMAT (a letter or 0 for natural format).  The data at VALADDR is in
+   target byte order.
+
+   If the data are a string pointer, returns the number of string characters
+   printed.
+
+   If DEREF_REF is nonzero, then dereference references, otherwise just print
+   them like pointers.
+
+   The PRETTY parameter controls prettyprinting.  */
+
+
+int
+pascal_val_print (struct type *type, char *valaddr, int embedded_offset,
+		  CORE_ADDR address, struct ui_file *stream, int format,
+		  int deref_ref, int recurse, enum val_prettyprint pretty)
+{
+  register unsigned int i = 0;	/* Number of characters printed */
+  unsigned len;
+  struct type *elttype;
+  unsigned eltlen;
+  LONGEST val;
+  CORE_ADDR addr;
+
+  CHECK_TYPEDEF (type);
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_ARRAY:
+      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
+	{
+	  elttype = check_typedef (TYPE_TARGET_TYPE (type));
+	  eltlen = TYPE_LENGTH (elttype);
+	  len = TYPE_LENGTH (type) / eltlen;
+	  if (prettyprint_arrays)
+	    {
+	      print_spaces_filtered (2 + 2 * recurse, stream);
+	    }
+	  /* For an array of chars, print with string syntax.  */
+	  if (eltlen == 1 &&
+	      ((TYPE_CODE (elttype) == TYPE_CODE_INT)
+	       || ((current_language->la_language == language_m2)
+		   && (TYPE_CODE (elttype) == TYPE_CODE_CHAR)))
+	      && (format == 0 || format == 's'))
+	    {
+	      /* If requested, look for the first null char and only print
+	         elements up to it.  */
+	      if (stop_print_at_null)
+		{
+		  unsigned int temp_len;
+
+		  /* Look for a NULL char. */
+		  for (temp_len = 0;
+		       (valaddr + embedded_offset)[temp_len]
+		       && temp_len < len && temp_len < print_max;
+		       temp_len++);
+		  len = temp_len;
+		}
+
+	      LA_PRINT_STRING (stream, valaddr + embedded_offset, len, 1, 0);
+	      i = len;
+	    }
+	  else
+	    {
+	      fprintf_filtered (stream, "{");
+	      /* If this is a virtual function table, print the 0th
+	         entry specially, and the rest of the members normally.  */
+	      if (pascal_object_is_vtbl_ptr_type (elttype))
+		{
+		  i = 1;
+		  fprintf_filtered (stream, "%d vtable entries", len - 1);
+		}
+	      else
+		{
+		  i = 0;
+		}
+	      val_print_array_elements (type, valaddr + embedded_offset, address, stream,
+				     format, deref_ref, recurse, pretty, i);
+	      fprintf_filtered (stream, "}");
+	    }
+	  break;
+	}
+      /* Array of unspecified length: treat like pointer to first elt.  */
+      addr = address;
+      goto print_unpacked_pointer;
+
+    case TYPE_CODE_PTR:
+      if (format && format != 's')
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	  break;
+	}
+      if (vtblprint && pascal_object_is_vtbl_ptr_type (type))
+	{
+	  /* Print the unmangled name if desired.  */
+	  /* Print vtable entry - we only get here if we ARE using
+	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.) */
+	  print_address_demangle (extract_address (valaddr + embedded_offset, TYPE_LENGTH (type)),
+				  stream, demangle);
+	  break;
+	}
+      elttype = check_typedef (TYPE_TARGET_TYPE (type));
+      if (TYPE_CODE (elttype) == TYPE_CODE_METHOD)
+	{
+	  pascal_object_print_class_method (valaddr + embedded_offset, type, stream);
+	}
+      else if (TYPE_CODE (elttype) == TYPE_CODE_MEMBER)
+	{
+	  pascal_object_print_class_member (valaddr + embedded_offset,
+				 TYPE_DOMAIN_TYPE (TYPE_TARGET_TYPE (type)),
+					    stream, "&");
+	}
+      else
+	{
+	  addr = unpack_pointer (type, valaddr + embedded_offset);
+	print_unpacked_pointer:
+	  elttype = check_typedef (TYPE_TARGET_TYPE (type));
+
+	  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)
+	    {
+	      /* Try to print what function it points to.  */
+	      print_address_demangle (addr, stream, demangle);
+	      /* Return value is irrelevant except for string pointers.  */
+	      return (0);
+	    }
+
+	  if (addressprint && format != 's')
+	    {
+	      print_address_numeric (addr, 1, stream);
+	    }
+
+	  /* For a pointer to char or unsigned char, also print the string
+	     pointed to, unless pointer is null.  */
+	  if (TYPE_LENGTH (elttype) == 1
+	      && TYPE_CODE (elttype) == TYPE_CODE_INT
+	      && (format == 0 || format == 's')
+	      && addr != 0)
+	    {
+	      /* no wide string yet */
+	      i = val_print_string (addr, -1, 1, stream);
+	    }
+	  /* also for pointers to pascal strings */
+	  /* Note: this is Free Pascal specific:
+	     as GDB does not recognize stabs pascal strings
+	     Pascal strings are mapped to records
+	     with lowercase names PM  */
+	  /* I don't know what GPC does :( PM */
+	  if (TYPE_CODE (elttype) == TYPE_CODE_STRUCT &&
+	       ((TYPE_NFIELDS (elttype) == 2 &&
+	        strcmp (TYPE_FIELDS (elttype)[0].name, "length") == 0 &&
+	        strcmp (TYPE_FIELDS (elttype)[1].name, "st") == 0) ||
+	       (TYPE_NFIELDS (elttype) == 3 &&
+	        strcmp (TYPE_FIELDS (elttype)[0].name, "Capacity") == 0 &&
+	        strcmp (TYPE_FIELDS (elttype)[1].name, "length") == 0 &&
+	        strcmp (TYPE_FIELDS (elttype)[2].name, "string") == 0)) &&
+	      addr != 0)
+	    {
+         if (TYPE_NFIELDS (elttype) == 2)
+           {
+	          char bytelength;
+  	          read_memory (addr, &bytelength, 1);
+	          i = val_print_string (addr + 1, bytelength, 1, stream);
+           }
+         else
+           {
+             LONGEST length;
+             int len;
+             length = read_memory_integer(addr + TYPE_FIELD_BITPOS (elttype,1) / 8,
+               TYPE_FIELD_BITSIZE (elttype,1) /8);
+             len = length;
+	          i = val_print_string (addr + TYPE_FIELD_BITPOS (elttype,2) / 8,
+               len, 1, stream);
+           }
+	    }
+	  else if (pascal_object_is_vtbl_member (type))
+	    {
+	      /* print vtbl's nicely */
+	      CORE_ADDR vt_address = unpack_pointer (type, valaddr + embedded_offset);
+
+	      struct minimal_symbol *msymbol =
+	      lookup_minimal_symbol_by_pc (vt_address);
+	      if ((msymbol != NULL) &&
+		  (vt_address == SYMBOL_VALUE_ADDRESS (msymbol)))
+		{
+		  fputs_filtered (" <", stream);
+		  fputs_filtered (SYMBOL_SOURCE_NAME (msymbol), stream);
+		  fputs_filtered (">", stream);
+		}
+	      if (vt_address && vtblprint)
+		{
+		  value_ptr vt_val;
+		  struct symbol *wsym = (struct symbol *) NULL;
+		  struct type *wtype;
+		  struct symtab *s;
+		  struct block *block = (struct block *) NULL;
+		  int is_this_fld;
+
+		  if (msymbol != NULL)
+		    wsym = lookup_symbol (SYMBOL_NAME (msymbol), block,
+					  VAR_NAMESPACE, &is_this_fld, &s);
+
+		  if (wsym)
+		    {
+		      wtype = SYMBOL_TYPE (wsym);
+		    }
+		  else
+		    {
+		      wtype = TYPE_TARGET_TYPE (type);
+		    }
+		  vt_val = value_at (wtype, vt_address, NULL);
+		  val_print (VALUE_TYPE (vt_val), VALUE_CONTENTS (vt_val), 0,
+			     VALUE_ADDRESS (vt_val), stream, format,
+			     deref_ref, recurse + 1, pretty);
+		  if (pretty)
+		    {
+		      fprintf_filtered (stream, "\n");
+		      print_spaces_filtered (2 + 2 * recurse, stream);
+		    }
+		}
+	    }
+
+	  /* Return number of characters printed, including the terminating
+	     '\0' if we reached the end.  val_print_string takes care including
+	     the terminating '\0' if necessary.  */
+	  return i;
+	}
+      break;
+
+    case TYPE_CODE_MEMBER:
+      error ("not implemented: member type in pascal_val_print");
+      break;
+
+    case TYPE_CODE_REF:
+      elttype = check_typedef (TYPE_TARGET_TYPE (type));
+      if (TYPE_CODE (elttype) == TYPE_CODE_MEMBER)
+	{
+	  pascal_object_print_class_member (valaddr + embedded_offset,
+					    TYPE_DOMAIN_TYPE (elttype),
+					    stream, "");
+	  break;
+	}
+      if (addressprint)
+	{
+	  fprintf_filtered (stream, "@");
+	  print_address_numeric
+	    (extract_address (valaddr + embedded_offset,
+			      TARGET_PTR_BIT / HOST_CHAR_BIT), 1, stream);
+	  if (deref_ref)
+	    fputs_filtered (": ", stream);
+	}
+      /* De-reference the reference.  */
+      if (deref_ref)
+	{
+	  if (TYPE_CODE (elttype) != TYPE_CODE_UNDEF)
+	    {
+	      value_ptr deref_val =
+	      value_at
+	      (TYPE_TARGET_TYPE (type),
+	       unpack_pointer (lookup_pointer_type (builtin_type_void),
+			       valaddr + embedded_offset),
+	       NULL);
+	      val_print (VALUE_TYPE (deref_val),
+			 VALUE_CONTENTS (deref_val), 0,
+			 VALUE_ADDRESS (deref_val), stream, format,
+			 deref_ref, recurse + 1, pretty);
+	    }
+	  else
+	    fputs_filtered ("???", stream);
+	}
+      break;
+
+    case TYPE_CODE_UNION:
+      if (recurse && !unionprint)
+	{
+	  fprintf_filtered (stream, "{...}");
+	  break;
+	}
+      /* Fall through.  */
+    case TYPE_CODE_STRUCT:
+      if (vtblprint && pascal_object_is_vtbl_ptr_type (type))
+	{
+	  /* Print the unmangled name if desired.  */
+	  /* Print vtable entry - we only get here if NOT using
+	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.) */
+	  print_address_demangle (extract_address (
+						    valaddr + embedded_offset + TYPE_FIELD_BITPOS (type, VTBL_FNADDR_OFFSET) / 8,
+		  TYPE_LENGTH (TYPE_FIELD_TYPE (type, VTBL_FNADDR_OFFSET))),
+				  stream, demangle);
+	}
+      else
+	{
+	  if  ((TYPE_NFIELDS (type) == 2 &&
+	        strcmp (TYPE_FIELDS (type)[0].name, "length") == 0 &&
+	        strcmp (TYPE_FIELDS (type)[1].name, "st") == 0) ||
+	       (TYPE_NFIELDS (type) == 3 &&
+	        strcmp (TYPE_FIELDS (type)[0].name, "Capacity") == 0 &&
+	        strcmp (TYPE_FIELDS (type)[1].name, "length") == 0 &&
+	        strcmp (TYPE_FIELDS (type)[2].name, "string") == 0)
+         )
+	    {
+         if (TYPE_NFIELDS (type) == 2)
+           {
+	          len = (*(valaddr + embedded_offset)) & 0xff;
+    	       LA_PRINT_STRING (stream, valaddr + embedded_offset + 1, len, /* width ?? */ 0, 0);
+           }
+         else
+           {
+   	      len = (*(valaddr + embedded_offset + TYPE_FIELD_BITPOS (type,1) / 8));
+	         LA_PRINT_STRING (stream, valaddr + embedded_offset + TYPE_FIELD_BITPOS (type,2) / 8, len, /* width ?? */ 0, 0);
+           }
+	    }
+	  else
+	    pascal_object_print_value_fields (type, valaddr + embedded_offset, address, stream, format,
+					      recurse, pretty, NULL, 0);
+	}
+      break;
+
+    case TYPE_CODE_ENUM:
+      if (format)
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	  break;
+	}
+      len = TYPE_NFIELDS (type);
+      val = unpack_long (type, valaddr + embedded_offset);
+      for (i = 0; i < len; i++)
+	{
+	  QUIT;
+	  if (val == TYPE_FIELD_BITPOS (type, i))
+	    {
+	      break;
+	    }
+	}
+      if (i < len)
+	{
+	  fputs_filtered (TYPE_FIELD_NAME (type, i), stream);
+	}
+      else
+	{
+	  print_longest (stream, 'd', 0, val);
+	}
+      break;
+
+    case TYPE_CODE_FUNC:
+      if (format)
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	  break;
+	}
+      /* FIXME, we should consider, at least for ANSI C language, eliminating
+         the distinction made between FUNCs and POINTERs to FUNCs.  */
+      fprintf_filtered (stream, "{");
+      type_print (type, "", stream, -1);
+      fprintf_filtered (stream, "} ");
+      /* Try to print what function it points to, and its address.  */
+      print_address_demangle (address, stream, demangle);
+      break;
+
+    case TYPE_CODE_BOOL:
+      format = format ? format : output_format;
+      if (format)
+	print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+      else
+	{
+	  val = unpack_long (type, valaddr + embedded_offset);
+	  if (val == 0)
+	    fputs_filtered ("false", stream);
+	  else if (val == 1)
+	    fputs_filtered ("true", stream);
+	  else
+	    {
+	      fputs_filtered ("true (", stream);
+	      fprintf_filtered (stream, "%ld)", (long int) val);
+	    }
+	}
+      break;
+
+    case TYPE_CODE_RANGE:
+      /* FIXME: create_range_type does not set the unsigned bit in a
+         range type (I think it probably should copy it from the target
+         type), so we won't print values which are too large to
+         fit in a signed integer correctly.  */
+      /* FIXME: Doesn't handle ranges of enums correctly.  (Can't just
+         print with the target type, though, because the size of our type
+         and the target type might differ).  */
+      /* FALLTHROUGH */
+
+    case TYPE_CODE_INT:
+      format = format ? format : output_format;
+      if (format)
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	}
+      else
+	{
+	  val_print_type_code_int (type, valaddr + embedded_offset, stream);
+	}
+      break;
+
+    case TYPE_CODE_CHAR:
+      format = format ? format : output_format;
+      if (format)
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	}
+      else
+	{
+	  val = unpack_long (type, valaddr + embedded_offset);
+	  if (TYPE_UNSIGNED (type))
+	    fprintf_filtered (stream, "%u", (unsigned int) val);
+	  else
+	    fprintf_filtered (stream, "%d", (int) val);
+	  fputs_filtered (" ", stream);
+	  LA_PRINT_CHAR ((unsigned char) val, stream);
+	}
+      break;
+
+    case TYPE_CODE_FLT:
+      if (format)
+	{
+	  print_scalar_formatted (valaddr + embedded_offset, type, format, 0, stream);
+	}
+      else
+	{
+	  print_floating (valaddr + embedded_offset, type, stream);
+	}
+      break;
+
+    case TYPE_CODE_BITSTRING:
+    case TYPE_CODE_SET:
+      elttype = TYPE_INDEX_TYPE (type);
+      CHECK_TYPEDEF (elttype);
+      if (TYPE_FLAGS (elttype) & TYPE_FLAG_STUB)
+	{
+	  fprintf_filtered (stream, "<incomplete type>");
+	  gdb_flush (stream);
+	  break;
+	}
+      else
+	{
+	  struct type *range = elttype;
+	  LONGEST low_bound, high_bound;
+	  int i;
+	  int is_bitstring = TYPE_CODE (type) == TYPE_CODE_BITSTRING;
+	  int need_comma = 0;
+
+	  if (is_bitstring)
+	    fputs_filtered ("B'", stream);
+	  else
+	    fputs_filtered ("[", stream);
+
+	  i = get_discrete_bounds (range, &low_bound, &high_bound);
+	maybe_bad_bstring:
+	  if (i < 0)
+	    {
+	      fputs_filtered ("<error value>", stream);
+	      goto done;
+	    }
+
+	  for (i = low_bound; i <= high_bound; i++)
+	    {
+	      int element = value_bit_index (type, valaddr + embedded_offset, i);
+	      if (element < 0)
+		{
+		  i = element;
+		  goto maybe_bad_bstring;
+		}
+	      if (is_bitstring)
+		fprintf_filtered (stream, "%d", element);
+	      else if (element)
+		{
+		  if (need_comma)
+		    fputs_filtered (", ", stream);
+		  print_type_scalar (range, i, stream);
+		  need_comma = 1;
+
+		  if (i + 1 <= high_bound && value_bit_index (type, valaddr + embedded_offset, ++i))
+		    {
+		      int j = i;
+		      fputs_filtered ("..", stream);
+		      while (i + 1 <= high_bound
+			     && value_bit_index (type, valaddr + embedded_offset, ++i))
+			j = i;
+		      print_type_scalar (range, j, stream);
+		    }
+		}
+	    }
+	done:
+	  if (is_bitstring)
+	    fputs_filtered ("'", stream);
+	  else
+	    fputs_filtered ("]", stream);
+	}
+      break;
+
+    case TYPE_CODE_VOID:
+      fprintf_filtered (stream, "void");
+      break;
+
+    case TYPE_CODE_ERROR:
+      fprintf_filtered (stream, "<error type>");
+      break;
+
+    case TYPE_CODE_UNDEF:
+      /* This happens (without TYPE_FLAG_STUB set) on systems which don't use
+         dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"
+         and no complete type for struct foo in that file.  */
+      fprintf_filtered (stream, "<incomplete type>");
+      break;
+
+    default:
+      error ("Invalid pascal type code %d in symbol table.", TYPE_CODE (type));
+    }
+  gdb_flush (stream);
+  return (0);
+}
+
+int
+pascal_value_print (value_ptr val, struct ui_file *stream, int format,
+		    enum val_prettyprint pretty)
+{
+  struct type *type = VALUE_TYPE (val);
+
+  /* If it is a pointer, indicate what it points to.
+
+     Print type also if it is a reference.
+
+     Object pascal: if it is a member pointer, we will take care
+     of that when we print it.  */
+  if (TYPE_CODE (type) == TYPE_CODE_PTR ||
+      TYPE_CODE (type) == TYPE_CODE_REF)
+    {
+      /* Hack:  remove (char *) for char strings.  Their
+         type is indicated by the quoted string anyway. */
+      if (TYPE_CODE (type) == TYPE_CODE_PTR &&
+	  TYPE_NAME (type) == NULL &&
+	  TYPE_NAME (TYPE_TARGET_TYPE (type)) != NULL &&
+	  STREQ (TYPE_NAME (TYPE_TARGET_TYPE (type)), "char"))
+	{
+	  /* Print nothing */
+	}
+      else
+	{
+	  fprintf_filtered (stream, "(");
+	  type_print (type, "", stream, -1);
+	  fprintf_filtered (stream, ") ");
+	}
+    }
+  return val_print (type, VALUE_CONTENTS (val), VALUE_EMBEDDED_OFFSET (val),
+		    VALUE_ADDRESS (val) + VALUE_OFFSET (val),
+		    stream, format, 1, 0, pretty);
+}
+
+
+/******************************************************************************
+                    Inserted from cp-valprint
+******************************************************************************/
+
+extern int vtblprint;		/* Controls printing of vtbl's */
+extern int objectprint;		/* Controls looking up an object's derived type
+				   using what we find in its vtables.  */
+static int pascal_static_field_print;	/* Controls printing of static fields. */
+
+static struct obstack dont_print_vb_obstack;
+static struct obstack dont_print_statmem_obstack;
+
+static void
+  pascal_object_print_static_field (struct type *, value_ptr, struct ui_file *, int, int,
+				    enum val_prettyprint);
+
+static void
+  pascal_object_print_value (struct type *, char *, CORE_ADDR, struct ui_file *,
+			     int, int, enum val_prettyprint, struct type **);
+
+void
+pascal_object_print_class_method (char *valaddr, struct type *type,
+				  struct ui_file *stream)
+{
+  struct type *domain;
+  struct fn_field *f = NULL;
+  int j = 0;
+  int len2;
+  int offset;
+  char *kind = "";
+  CORE_ADDR addr;
+  struct symbol *sym;
+  unsigned len;
+  unsigned int i;
+  struct type *target_type = check_typedef (TYPE_TARGET_TYPE (type));
+
+  domain = TYPE_DOMAIN_TYPE (target_type);
+  if (domain == (struct type *) NULL)
+    {
+      fprintf_filtered (stream, "<unknown>");
+      return;
+    }
+  addr = unpack_pointer (lookup_pointer_type (builtin_type_void), valaddr);
+  if (METHOD_PTR_IS_VIRTUAL (addr))
+    {
+      offset = METHOD_PTR_TO_VOFFSET (addr);
+      len = TYPE_NFN_FIELDS (domain);
+      for (i = 0; i < len; i++)
+	{
+	  f = TYPE_FN_FIELDLIST1 (domain, i);
+	  len2 = TYPE_FN_FIELDLIST_LENGTH (domain, i);
+
+	  for (j = 0; j < len2; j++)
+	    {
+	      QUIT;
+	      if (TYPE_FN_FIELD_VOFFSET (f, j) == offset)
+		{
+		  if (TYPE_FN_FIELD_STUB (f, j))
+		    check_stub_method (domain, i, j);
+		  kind = "virtual ";
+		  goto common;
+		}
+	    }
+	}
+    }
+  else
+    {
+      sym = find_pc_function (addr);
+      if (sym == 0)
+	{
+	  error ("invalid pointer to member function");
+	}
+      len = TYPE_NFN_FIELDS (domain);
+      for (i = 0; i < len; i++)
+	{
+	  f = TYPE_FN_FIELDLIST1 (domain, i);
+	  len2 = TYPE_FN_FIELDLIST_LENGTH (domain, i);
+
+	  for (j = 0; j < len2; j++)
+	    {
+	      QUIT;
+	      if (TYPE_FN_FIELD_STUB (f, j))
+		check_stub_method (domain, i, j);
+	      if (STREQ (SYMBOL_NAME (sym), TYPE_FN_FIELD_PHYSNAME (f, j)))
+		{
+		  goto common;
+		}
+	    }
+	}
+    }
+common:
+  if (i < len)
+    {
+      char *demangled_name;
+
+      fprintf_filtered (stream, "&");
+      fprintf_filtered (stream, kind);
+      demangled_name = cplus_demangle (TYPE_FN_FIELD_PHYSNAME (f, j),
+				       DMGL_ANSI | DMGL_PARAMS);
+      if (demangled_name == NULL)
+	fprintf_filtered (stream, "<badly mangled name %s>",
+			  TYPE_FN_FIELD_PHYSNAME (f, j));
+      else
+	{
+	  fputs_filtered (demangled_name, stream);
+	  free (demangled_name);
+	}
+    }
+  else
+    {
+      fprintf_filtered (stream, "(");
+      type_print (type, "", stream, -1);
+      fprintf_filtered (stream, ") %d", (int) addr >> 3);
+    }
+}
+
+/* It was changed to this after 2.4.5.  */
+const char pascal_vtbl_ptr_name[] =
+{'_', '_', 'v', 't', 'b', 'l', '_', 'p', 't', 'r', '_', 't', 'y', 'p', 'e', 0};
+
+/* Return truth value for assertion that TYPE is of the type
+   "pointer to virtual function".  */
+
+int
+pascal_object_is_vtbl_ptr_type (struct type *type)
+{
+  char *typename = type_name_no_tag (type);
+
+  return (typename != NULL
+	  && (STREQ (typename, pascal_vtbl_ptr_name)));
+}
+
+/* Return truth value for the assertion that TYPE is of the type
+   "pointer to virtual function table".  */
+
+int
+pascal_object_is_vtbl_member (struct type *type)
+{
+  if (TYPE_CODE (type) == TYPE_CODE_PTR)
+    {
+      type = TYPE_TARGET_TYPE (type);
+      if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
+	{
+	  type = TYPE_TARGET_TYPE (type);
+	  if (TYPE_CODE (type) == TYPE_CODE_STRUCT	/* if not using thunks */
+	      || TYPE_CODE (type) == TYPE_CODE_PTR)	/* if using thunks */
+	    {
+	      /* Virtual functions tables are full of pointers
+	         to virtual functions. */
+	      return pascal_object_is_vtbl_ptr_type (type);
+	    }
+	}
+    }
+  return 0;
+}
+
+/* Mutually recursive subroutines of pascal_object_print_value and c_val_print to
+   print out a structure's fields: pascal_object_print_value_fields and pascal_object_print_value.
+
+   TYPE, VALADDR, ADDRESS, STREAM, RECURSE, and PRETTY have the
+   same meanings as in pascal_object_print_value and c_val_print.
+
+   DONT_PRINT is an array of baseclass types that we
+   should not print, or zero if called from top level.  */
+
+void
+pascal_object_print_value_fields (struct type *type, char *valaddr,
+				  CORE_ADDR address, struct ui_file *stream,
+				  int format, int recurse,
+				  enum val_prettyprint pretty,
+				  struct type **dont_print_vb,
+				  int dont_print_statmem)
+{
+  int i, len, n_baseclasses;
+  struct obstack tmp_obstack;
+  char *last_dont_print = obstack_next_free (&dont_print_statmem_obstack);
+
+  CHECK_TYPEDEF (type);
+
+  fprintf_filtered (stream, "{");
+  len = TYPE_NFIELDS (type);
+  n_baseclasses = TYPE_N_BASECLASSES (type);
+
+  /* Print out baseclasses such that we don't print
+     duplicates of virtual baseclasses.  */
+  if (n_baseclasses > 0)
+    pascal_object_print_value (type, valaddr, address, stream,
+			       format, recurse + 1, pretty, dont_print_vb);
+
+  if (!len && n_baseclasses == 1)
+    fprintf_filtered (stream, "<No data fields>");
+  else
+    {
+      extern int inspect_it;
+      int fields_seen = 0;
+
+      if (dont_print_statmem == 0)
+	{
+	  /* If we're at top level, carve out a completely fresh
+	     chunk of the obstack and use that until this particular
+	     invocation returns.  */
+	  tmp_obstack = dont_print_statmem_obstack;
+	  obstack_finish (&dont_print_statmem_obstack);
+	}
+
+      for (i = n_baseclasses; i < len; i++)
+	{
+	  /* If requested, skip printing of static fields.  */
+	  if (!pascal_static_field_print && TYPE_FIELD_STATIC (type, i))
+	    continue;
+	  if (fields_seen)
+	    fprintf_filtered (stream, ", ");
+	  else if (n_baseclasses > 0)
+	    {
+	      if (pretty)
+		{
+		  fprintf_filtered (stream, "\n");
+		  print_spaces_filtered (2 + 2 * recurse, stream);
+		  fputs_filtered ("members of ", stream);
+		  fputs_filtered (type_name_no_tag (type), stream);
+		  fputs_filtered (": ", stream);
+		}
+	    }
+	  fields_seen = 1;
+
+	  if (pretty)
+	    {
+	      fprintf_filtered (stream, "\n");
+	      print_spaces_filtered (2 + 2 * recurse, stream);
+	    }
+	  else
+	    {
+	      wrap_here (n_spaces (2 + 2 * recurse));
+	    }
+	  if (inspect_it)
+	    {
+	      if (TYPE_CODE (TYPE_FIELD_TYPE (type, i)) == TYPE_CODE_PTR)
+		fputs_filtered ("\"( ptr \"", stream);
+	      else
+		fputs_filtered ("\"( nodef \"", stream);
+	      if (TYPE_FIELD_STATIC (type, i))
+		fputs_filtered ("static ", stream);
+	      fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
+				       language_cplus,
+				       DMGL_PARAMS | DMGL_ANSI);
+	      fputs_filtered ("\" \"", stream);
+	      fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
+				       language_cplus,
+				       DMGL_PARAMS | DMGL_ANSI);
+	      fputs_filtered ("\") \"", stream);
+	    }
+	  else
+	    {
+	      annotate_field_begin (TYPE_FIELD_TYPE (type, i));
+
+	      if (TYPE_FIELD_STATIC (type, i))
+		fputs_filtered ("static ", stream);
+	      fprintf_symbol_filtered (stream, TYPE_FIELD_NAME (type, i),
+				       language_cplus,
+				       DMGL_PARAMS | DMGL_ANSI);
+	      annotate_field_name_end ();
+	      fputs_filtered (" = ", stream);
+	      annotate_field_value ();
+	    }
+
+	  if (!TYPE_FIELD_STATIC (type, i) && TYPE_FIELD_PACKED (type, i))
+	    {
+	      value_ptr v;
+
+	      /* Bitfields require special handling, especially due to byte
+	         order problems.  */
+	      if (TYPE_FIELD_IGNORE (type, i))
+		{
+		  fputs_filtered ("<optimized out or zero length>", stream);
+		}
+	      else
+		{
+		  v = value_from_longest (TYPE_FIELD_TYPE (type, i),
+				   unpack_field_as_long (type, valaddr, i));
+
+		  val_print (TYPE_FIELD_TYPE (type, i), VALUE_CONTENTS (v), 0, 0,
+			     stream, format, 0, recurse + 1, pretty);
+		}
+	    }
+	  else
+	    {
+	      if (TYPE_FIELD_IGNORE (type, i))
+		{
+		  fputs_filtered ("<optimized out or zero length>", stream);
+		}
+	      else if (TYPE_FIELD_STATIC (type, i))
+		{
+		  /* value_ptr v = value_static_field (type, i); v4.17 specific */
+		  value_ptr v;
+		  v = value_from_longest (TYPE_FIELD_TYPE (type, i),
+				   unpack_field_as_long (type, valaddr, i));
+
+		  if (v == NULL)
+		    fputs_filtered ("<optimized out>", stream);
+		  else
+		    pascal_object_print_static_field (TYPE_FIELD_TYPE (type, i), v,
+						stream, format, recurse + 1,
+						      pretty);
+		}
+	      else
+		{
+		  /* val_print (TYPE_FIELD_TYPE (type, i),
+		     valaddr + TYPE_FIELD_BITPOS (type, i) / 8,
+		     address + TYPE_FIELD_BITPOS (type, i) / 8, 0,
+		     stream, format, 0, recurse + 1, pretty); */
+		  val_print (TYPE_FIELD_TYPE (type, i),
+			     valaddr, TYPE_FIELD_BITPOS (type, i) / 8,
+			     address + TYPE_FIELD_BITPOS (type, i) / 8,
+			     stream, format, 0, recurse + 1, pretty);
+		}
+	    }
+	  annotate_field_end ();
+	}
+
+      if (dont_print_statmem == 0)
+	{
+	  /* Free the space used to deal with the printing
+	     of the members from top level.  */
+	  obstack_free (&dont_print_statmem_obstack, last_dont_print);
+	  dont_print_statmem_obstack = tmp_obstack;
+	}
+
+      if (pretty)
+	{
+	  fprintf_filtered (stream, "\n");
+	  print_spaces_filtered (2 * recurse, stream);
+	}
+    }
+  fprintf_filtered (stream, "}");
+}
+
+/* Special val_print routine to avoid printing multiple copies of virtual
+   baseclasses.  */
+
+void
+pascal_object_print_value (struct type *type, char *valaddr, CORE_ADDR address,
+			   struct ui_file *stream, int format, int recurse,
+			   enum val_prettyprint pretty,
+			   struct type **dont_print_vb)
+{
+  struct obstack tmp_obstack;
+  struct type **last_dont_print
+  = (struct type **) obstack_next_free (&dont_print_vb_obstack);
+  int i, n_baseclasses = TYPE_N_BASECLASSES (type);
+
+  if (dont_print_vb == 0)
+    {
+      /* If we're at top level, carve out a completely fresh
+         chunk of the obstack and use that until this particular
+         invocation returns.  */
+      tmp_obstack = dont_print_vb_obstack;
+      /* Bump up the high-water mark.  Now alpha is omega.  */
+      obstack_finish (&dont_print_vb_obstack);
+    }
+
+  for (i = 0; i < n_baseclasses; i++)
+    {
+      int boffset;
+      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
+      char *basename = TYPE_NAME (baseclass);
+      char *base_valaddr;
+
+      if (BASETYPE_VIA_VIRTUAL (type, i))
+	{
+	  struct type **first_dont_print
+	  = (struct type **) obstack_base (&dont_print_vb_obstack);
+
+	  int j = (struct type **) obstack_next_free (&dont_print_vb_obstack)
+	  - first_dont_print;
+
+	  while (--j >= 0)
+	    if (baseclass == first_dont_print[j])
+	      goto flush_it;
+
+	  obstack_ptr_grow (&dont_print_vb_obstack, baseclass);
+	}
+
+      boffset = baseclass_offset (type, i, valaddr, address);
+
+      if (pretty)
+	{
+	  fprintf_filtered (stream, "\n");
+	  print_spaces_filtered (2 * recurse, stream);
+	}
+      fputs_filtered ("<", stream);
+      /* Not sure what the best notation is in the case where there is no
+         baseclass name.  */
+
+      fputs_filtered (basename ? basename : "", stream);
+      fputs_filtered ("> = ", stream);
+
+      /* The virtual base class pointer might have been clobbered by the
+         user program. Make sure that it still points to a valid memory
+         location.  */
+
+      if (boffset != -1 && (boffset < 0 || boffset >= TYPE_LENGTH (type)))
+	{
+	  base_valaddr = (char *) alloca (TYPE_LENGTH (baseclass));
+	  if (target_read_memory (address + boffset, base_valaddr,
+				  TYPE_LENGTH (baseclass)) != 0)
+	    boffset = -1;
+	}
+      else
+	base_valaddr = valaddr + boffset;
+
+      if (boffset == -1)
+	fprintf_filtered (stream, "<invalid address>");
+      else
+	pascal_object_print_value_fields (baseclass, base_valaddr, address + boffset,
+					  stream, format, recurse, pretty,
+		     (struct type **) obstack_base (&dont_print_vb_obstack),
+					  0);
+      fputs_filtered (", ", stream);
+
+    flush_it:
+      ;
+    }
+
+  if (dont_print_vb == 0)
+    {
+      /* Free the space used to deal with the printing
+         of this type from top level.  */
+      obstack_free (&dont_print_vb_obstack, last_dont_print);
+      /* Reset watermark so that we can continue protecting
+         ourselves from whatever we were protecting ourselves.  */
+      dont_print_vb_obstack = tmp_obstack;
+    }
+}
+
+/* Print value of a static member.
+   To avoid infinite recursion when printing a class that contains
+   a static instance of the class, we keep the addresses of all printed
+   static member classes in an obstack and refuse to print them more
+   than once.
+
+   VAL contains the value to print, TYPE, STREAM, RECURSE, and PRETTY
+   have the same meanings as in c_val_print.  */
+
+static void
+pascal_object_print_static_field (struct type *type, value_ptr val,
+				  struct ui_file *stream, int format,
+				  int recurse, enum val_prettyprint pretty)
+{
+  if (TYPE_CODE (type) == TYPE_CODE_STRUCT)
+    {
+      CORE_ADDR *first_dont_print;
+      int i;
+
+      first_dont_print
+	= (CORE_ADDR *) obstack_base (&dont_print_statmem_obstack);
+      i = (CORE_ADDR *) obstack_next_free (&dont_print_statmem_obstack)
+	- first_dont_print;
+
+      while (--i >= 0)
+	{
+	  if (VALUE_ADDRESS (val) == first_dont_print[i])
+	    {
+	      fputs_filtered ("<same as static member of an already seen type>",
+			      stream);
+	      return;
+	    }
+	}
+
+      obstack_grow (&dont_print_statmem_obstack, (char *) &VALUE_ADDRESS (val),
+		    sizeof (CORE_ADDR));
+
+      CHECK_TYPEDEF (type);
+      pascal_object_print_value_fields (type, VALUE_CONTENTS (val), VALUE_ADDRESS (val),
+				  stream, format, recurse, pretty, NULL, 1);
+      return;
+    }
+  val_print (type, VALUE_CONTENTS (val), 0, VALUE_ADDRESS (val),
+	     stream, format, 0, recurse, pretty);
+}
+
+void
+pascal_object_print_class_member (char *valaddr, struct type *domain,
+				  struct ui_file *stream, char *prefix)
+{
+
+  /* VAL is a byte offset into the structure type DOMAIN.
+     Find the name of the field for that offset and
+     print it.  */
+  int extra = 0;
+  int bits = 0;
+  register unsigned int i;
+  unsigned len = TYPE_NFIELDS (domain);
+  /* @@ Make VAL into bit offset */
+  LONGEST val = unpack_long (builtin_type_int, valaddr) << 3;
+  for (i = TYPE_N_BASECLASSES (domain); i < len; i++)
+    {
+      int bitpos = TYPE_FIELD_BITPOS (domain, i);
+      QUIT;
+      if (val == bitpos)
+	break;
+      if (val < bitpos && i != 0)
+	{
+	  /* Somehow pointing into a field.  */
+	  i -= 1;
+	  extra = (val - TYPE_FIELD_BITPOS (domain, i));
+	  if (extra & 0x7)
+	    bits = 1;
+	  else
+	    extra >>= 3;
+	  break;
+	}
+    }
+  if (i < len)
+    {
+      char *name;
+      fprintf_filtered (stream, prefix);
+      name = type_name_no_tag (domain);
+      if (name)
+	fputs_filtered (name, stream);
+      else
+	pascal_type_print_base (domain, stream, 0, 0);
+      fprintf_filtered (stream, "::");
+      fputs_filtered (TYPE_FIELD_NAME (domain, i), stream);
+      if (extra)
+	fprintf_filtered (stream, " + %d bytes", extra);
+      if (bits)
+	fprintf_filtered (stream, " (offset in bits)");
+    }
+  else
+    fprintf_filtered (stream, "%ld", (long int) (val >> 3));
+}
+
+
+void
+_initialize_pascal_valprint (void)
+{
+  add_show_from_set
+    (add_set_cmd ("pascal_static-members", class_support, var_boolean,
+		  (char *) &pascal_static_field_print,
+		  "Set printing of pascal static members.",
+		  &setprintlist),
+     &showprintlist);
+  /* Turn on printing of static fields.  */
+  pascal_static_field_print = 1;
+
+}
diff -urN origdb/source.c gdb/source.c
--- origdb/source.c	Tue Apr  4 03:08:52 2000
+++ gdb/source.c	Thu Nov  2 12:41:02 2000
@@ -536,7 +536,7 @@
   if (!path)
     path = ".";

-#ifdef _WIN32
+#if defined (_WIN32) || defined (__MSDOS__)
   mode |= O_BINARY;
 #endif

@@ -1586,7 +1586,7 @@

       /* we now have a source line in buf, null terminate and match */
       *p = 0;
-      if (re_exec (buf) > 0)
+    if (re_iexec (buf,(int) (current_language->la_language == language_pascal)) > 0)
 	{
 	  /* Match! */
 	  fclose (stream);
@@ -1696,7 +1696,7 @@

       /* We now have a source line in buf; null terminate and match.  */
       *p = 0;
-      if (re_exec (buf) > 0)
+      if (re_iexec (buf,(int) (current_language->la_language == language_pascal)) > 0)
 	{
 	  /* Match! */
 	  fclose (stream);
diff -urN origdb/stabsread.c gdb/stabsread.c
--- origdb/stabsread.c	Tue Feb  8 05:39:02 2000
+++ gdb/stabsread.c	Thu Nov  2 12:51:54 2000
@@ -2006,10 +2006,17 @@

 	         Fortunately, this check seems not to be necessary
 	         for anything except pointers or functions.  */
-	    }
-	  else
-	    TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NAME (sym);
-	}
+		 if ((TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_PTR) &&
+          (current_subfile->language == language_pascal))
+         {
+           TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NAME (sym);
+         }
+       }
+     else
+       {
+         TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NAME (sym);
+       }
+	 }

       add_symbol_to_list (sym, &file_symbols);
       break;
diff -urN origdb/symfile.c gdb/symfile.c
--- origdb/symfile.c	Mon Apr  3 16:16:12 2000
+++ gdb/symfile.c	Thu Nov  2 12:41:02 2000
@@ -2048,6 +2048,10 @@
       add_filename_language (".F", language_fortran);
       add_filename_language (".s", language_asm);
       add_filename_language (".S", language_asm);
+      add_filename_language (".pas",   language_pascal);
+      add_filename_language (".p",     language_pascal);
+      add_filename_language (".pp",    language_pascal);
+      add_filename_language (".inc",   language_pascal);
     }
 }

diff -urN origdb/symtab.c gdb/symtab.c
--- origdb/symtab.c	Tue Apr  4 03:08:52 2000
+++ gdb/symtab.c	Thu Nov  2 12:50:06 2000
@@ -3667,6 +3667,14 @@
 	    }
 	}

+      if (current_language->la_language == language_pascal)
+        {
+          create_case_insensitive_translate_buffer();
+        }
+      else
+        {
+          reset_translate_buffer();
+        }
       if (0 != (val = re_comp (regexp)))
 	error ("Invalid regexp (%s): %s", val, regexp);
     }
@@ -3876,6 +3884,8 @@
      int block;
      char *last;
 {
+  enum language store_current=current_language->la_language;
+
   if (last == NULL || strcmp (last, s->filename) != 0)
     {
       fputs_filtered ("\nFile ", gdb_stdout);
@@ -3895,11 +3905,17 @@
 	   (kind == TYPES_NAMESPACE &&
 	    SYMBOL_NAMESPACE (sym) == STRUCT_NAMESPACE))
     {
+     /*  Try to respect the local language  */
+      if ((language_mode == language_mode_auto) &&
+          (SYMBOL_LANGUAGE(sym) != language_unknown) &&
+           /* Is this possible ??? */
+          (SYMBOL_LANGUAGE(sym) != language_auto) &&
+          (current_language->la_language != SYMBOL_LANGUAGE(sym)))
+         set_language(SYMBOL_LANGUAGE(sym));
       type_print (SYMBOL_TYPE (sym),
 		  (SYMBOL_CLASS (sym) == LOC_TYPEDEF
 		   ? "" : SYMBOL_SOURCE_NAME (sym)),
 		  gdb_stdout, 0);
-
       printf_filtered (";\n");
     }
   else
@@ -3926,6 +3942,8 @@
 	}
 #endif
     }
+  if (store_current != current_language->la_language)
+    set_language(store_current);
 }

 /* This help function for symtab_symbol_info() prints information
@@ -4060,9 +4078,21 @@
 					  + strlen (SYMBOL_NAME (p->symbol))
 					  + 4);
 	  strcpy (string, p->symtab->filename);
-	  strcat (string, ":'");
-	  strcat (string, SYMBOL_NAME (p->symbol));
-	  strcat (string, "'");
+     /* Use line number for pascal as overloaded are allowed */
+     if ((SYMBOL_LANGUAGE(p->symbol) == language_pascal) &&
+         (SYMBOL_LINE (p->symbol) > 0))
+       {
+        char binary_str[33];
+        strcat (string, ":");
+        sprintf(binary_str,"%d",SYMBOL_LINE (p->symbol));
+        strcat (string, binary_str);
+       }
+     else
+       {
+         strcat (string, ":'");
+	      strcat (string, SYMBOL_NAME (p->symbol));
+	      strcat (string, "'");
+       }
 	  break_command (string, from_tty);
 	  print_symbol_info (FUNCTIONS_NAMESPACE,
 			     p->symtab,
diff -urN origdb/symtab.h gdb/symtab.h
--- origdb/symtab.h	Mon Apr  3 05:47:26 2000
+++ gdb/symtab.h	Thu Nov  2 12:41:02 2000
@@ -281,9 +281,9 @@
    Evaluates to zero if the match fails, or nonzero if it succeeds. */

 #define SYMBOL_MATCHES_REGEXP(symbol)					\
-  (re_exec (SYMBOL_NAME (symbol)) != 0					\
+  (re_iexec (SYMBOL_NAME (symbol),(int) (current_language->la_language == language_pascal)) != 0					\
    || (SYMBOL_DEMANGLED_NAME (symbol) != NULL				\
-       && re_exec (SYMBOL_DEMANGLED_NAME (symbol)) != 0))
+       && re_iexec (SYMBOL_DEMANGLED_NAME (symbol),(int) (current_language->la_language == language_pascal)) != 0))

 /* Define a simple structure used to hold some very basic information about
    all defined global symbols (text, data, bss, abs, etc).  The only required
diff -urN origdb/top.c gdb/top.c
--- origdb/top.c	Wed Apr 12 17:46:02 2000
+++ gdb/top.c	Mon Nov 20 12:12:16 2000
@@ -3211,6 +3211,7 @@

   /* After the required info we print the configuration information. */

+  fprintf_filtered (stream, "Pascal language support by Pierre Muller\n");
   fprintf_filtered (stream, "This GDB was configured as \"");
   if (!STREQ (host_name, target_name))
     {
diff -urN origdb/utils.c gdb/utils.c
--- origdb/utils.c	Fri Apr 21 05:10:46 2000
+++ gdb/utils.c	Mon Nov 20 12:34:48 2000
@@ -125,7 +125,7 @@
 /* Nonzero means that encoded C++ names should be printed out in their
    C++ form rather than raw.  */

-int demangle = 1;
+int demangle = 0;

 /* Nonzero means that encoded C++ names should be printed out in their
    C++ form even in assembler language displays.  If this is set, but
@@ -2224,6 +2224,7 @@
 	{
 	  switch (lang)
 	    {
+	    case language_pascal:
 	    case language_cplus:
 	      demangled = cplus_demangle (name, arg_mode);
 	      break;
diff -urN origdb/valarith.c gdb/valarith.c
--- origdb/valarith.c	Tue Dec 14 02:05:38 1999
+++ gdb/valarith.c	Thu Nov  2 12:41:04 2000
@@ -896,6 +896,7 @@
 	      break;

 	    case BINOP_DIV:
+	    case BINOP_INTDIV:
 	      v = v1 / v2;
 	      break;

@@ -1020,6 +1021,7 @@
 	      break;

 	    case BINOP_DIV:
+	    case BINOP_INTDIV:
 	      v = v1 / v2;
               break;

diff -urN origdb/valops.c gdb/valops.c
--- origdb/valops.c	Sun Apr  9 14:02:10 2000
+++ gdb/valops.c	Fri Dec  1 14:55:34 2000
@@ -315,7 +315,8 @@
 	         type of the source as a superclass.  If so, we'll need to
 	         offset the pointer rather than just change its type.
 	         FIXME: This fails silently with virtual inheritance.  */
-	      if (TYPE_NAME (t2) != NULL)
+	      if (TYPE_NAME (t2) != NULL
+	          && current_language->la_language != language_pascal)
 		{
 		  v = search_struct_field (type_name_no_tag (t2),
 				       value_zero (t1, not_lval), 0, t1, 1);
