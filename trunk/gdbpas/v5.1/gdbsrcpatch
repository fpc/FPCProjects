diff -r -b -c -N origdb/breakpoint.c gdb/breakpoint.c
*** origdb/breakpoint.c	Sun Nov 11 16:39:14 2001
--- gdb/breakpoint.c	Wed Jan 23 11:35:05 2002
***************
*** 234,239 ****
--- 234,251 ----
  	     B ? (TMP=B->next, 1): 0;	\
  	     B = TMP)
  
+ #ifndef REMOVE_HARDWARE_BREAKPOINT_AT_EXIT
+ #define REMOVE_HARDWARE_BREAKPOINT_AT_EXIT 0
+ #endif
+ 
+ #ifndef REMOVE_HARDWARE_WATCHPOINT_AT_EXIT
+ #define REMOVE_HARDWARE_WATCHPOINT_AT_EXIT 0
+ #endif
+ 
+ #ifndef HARDWARE_REGISTERS_RESET
+ #define HARDWARE_REGISTERS_RESET {}
+ #endif
+ 
  /* True if SHIFT_INST_REGS defined, false otherwise.  */
  
  int must_shift_inst_regs =
***************
*** 1439,1444 ****
--- 1451,1492 ----
  
    ALL_BREAKPOINTS_SAFE (b, temp)
    {
+         /* Disabled, does not work correctly
+ 	if ((b->type == bp_hardware_watchpoint
+ 	       || b->type == bp_watchpoint
+ 	       || b->type == bp_access_watchpoint
+ 	       || b->type == bp_read_watchpoint)
+ 	     && (context == inf_exited))
+ 	 {
+ 	  if (b->val)
+ 	    value_free (b->val);
+ 	  b->val = NULL;
+          } */
+         if ((((REMOVE_HARDWARE_BREAKPOINT_AT_EXIT)
+ 		&& b->type == bp_hardware_breakpoint)
+ 	       ||((REMOVE_HARDWARE_WATCHPOINT_AT_EXIT)
+ 		  && (b->type == bp_hardware_watchpoint
+ 		      || b->type == bp_access_watchpoint
+ 	              || b->type == bp_read_watchpoint)))
+                    && b->inserted
+ 		   && context == inf_exited)
+    	 remove_breakpoint (b, mark_uninserted);
+ 
+ 	/* Also disabled
+ 	if (b->type == bp_hardware_watchpoint
+ 	       || b->type == bp_watchpoint
+ 	       || b->type == bp_access_watchpoint
+ 	       || b->type == bp_read_watchpoint)
+ 	{
+ 	  struct value * val;
+ 	  struct value * mark = value_mark (); 
+ 	  val = evaluate_expression (b->exp);
+ 	  release_value (val);
+ 	  if (VALUE_LAZY (val))
+ 	   value_fetch_lazy (val);
+ 	  b->val = val;
+ 	  value_free_to_mark (mark);
+ 	 } */
      b->inserted = 0;
  
      switch (b->type)
***************
*** 1486,1491 ****
--- 1534,1541 ----
        warning ("You must reinsert them explicitly.");
        warning_needed = 0;
      }
+   if (context == inf_exited)
+     HARDWARE_REGISTERS_RESET;
  }
  
  /* breakpoint_here_p (PC) returns non-zero if an enabled breakpoint
***************
*** 7134,7141 ****
  	    xfree (b->cond);
  	  b->cond = parse_exp_1 (&s, (struct block *) 0, 0);
  	}
        if (b->enable_state == bp_enabled)
! 	mention (b);
        value_free_to_mark (mark);
        break;
      case bp_catch_catch:
--- 7184,7192 ----
  	    xfree (b->cond);
  	  b->cond = parse_exp_1 (&s, (struct block *) 0, 0);
  	}
+       /* Generates lot of noise
  	if (b->enable_state == bp_enabled)
! 	mention (b); */
        value_free_to_mark (mark);
        break;
      case bp_catch_catch:
diff -r -b -c -N origdb/config/i386/cygwin.mh gdb/config/i386/cygwin.mh
*** origdb/config/i386/cygwin.mh	Sun Aug 27 04:21:35 2000
--- gdb/config/i386/cygwin.mh	Wed Jan 23 10:23:40 2002
***************
*** 1,6 ****
  MH_CFLAGS=
  XM_FILE=xm-cygwin.h
  XDEPFILES=
! NATDEPFILES= win32-nat.o corelow.o
! NAT_FILE=../none/nm-none.h
  XM_CLIBS=
--- 1,6 ----
  MH_CFLAGS=
  XM_FILE=xm-cygwin.h
  XDEPFILES=
! NATDEPFILES= i386-nat.o win32-nat.o corelow.o
! NAT_FILE=nm-cygwin.h
  XM_CLIBS=
diff -r -b -c -N origdb/config/i386/nm-cygwin.h gdb/config/i386/nm-cygwin.h
*** origdb/config/i386/nm-cygwin.h	Thu Jan  1 00:00:00 1970
--- gdb/config/i386/nm-cygwin.h	Wed Jan 23 10:28:37 2002
***************
*** 0 ****
--- 1,38 ----
+ /* Native definitions for Intel x86 running CYGWIN.
+    Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+ 
+    This file is part of GDB.
+ 
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+ 
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+ 
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.  */
+ 
+ #define NO_PTRACE_H
+ 
+ #define I386_USE_GENERIC_WATCHPOINTS
+ 
+ #include "i386/nm-i386.h"
+ 
+ /* Support for hardware-assisted breakpoints and watchpoints.  */
+ 
+ #define I386_DR_LOW_SET_CONTROL(VAL)	cygwin_set_dr7 (VAL)
+ extern void cygwin_set_dr7 (unsigned);
+ 
+ #define I386_DR_LOW_SET_ADDR(N,ADDR)	cygwin_set_dr (N,ADDR)
+ extern void cygwin_set_dr (int, CORE_ADDR);
+ 
+ #define I386_DR_LOW_RESET_ADDR(N)
+ 
+ #define I386_DR_LOW_GET_STATUS()	cygwin_get_dr6 ()
+ extern unsigned cygwin_get_dr6 (void);
diff -r -b -c -N origdb/config/i386/nm-i386.h gdb/config/i386/nm-i386.h
*** origdb/config/i386/nm-i386.h	Fri Mar 23 16:17:45 2001
--- gdb/config/i386/nm-i386.h	Wed Jan 23 10:22:32 2002
***************
*** 115,120 ****
--- 115,126 ----
  
  #define DECR_PC_AFTER_HW_BREAK 0
  
+ #define REMOVE_HARDWARE_WATCHPOINT_AT_EXIT 1
+ 
+ #define REMOVE_HARDWARE_BREAKPOINT_AT_EXIT 1
+ 
+ #define HARDWARE_REGISTERS_RESET i386_cleanup_dregs ()
+ 
  #endif /* I386_USE_GENERIC_WATCHPOINTS */
  
  #endif /* NM_I386_H */
diff -r -b -c -N origdb/go32-nat.c gdb/go32-nat.c
*** origdb/go32-nat.c	Fri Aug 24 04:56:51 2001
--- gdb/go32-nat.c	Wed Jan 23 10:12:36 2002
***************
*** 674,680 ****
       be nice if GDB itself would take care to remove all breakpoints
       at all times, but it doesn't, probably under an assumption that
       the OS cleans up when the debuggee exits.  */
!   i386_cleanup_dregs ();
    go32_kill_inferior ();
    generic_mourn_inferior ();
  }
--- 674,680 ----
       be nice if GDB itself would take care to remove all breakpoints
       at all times, but it doesn't, probably under an assumption that
       the OS cleans up when the debuggee exits.  */
!   // i386_cleanup_dregs (); done in breakpoint_init_inferior
    go32_kill_inferior ();
    generic_mourn_inferior ();
  }
diff -r -b -c -N origdb/i386-linux-nat.c gdb/i386-linux-nat.c
*** origdb/i386-linux-nat.c	Tue May 15 00:03:36 2001
--- gdb/i386-linux-nat.c	Wed Jan 23 10:15:04 2002
***************
*** 259,264 ****
--- 259,265 ----
    for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
      {
        errno = 0;
+       if (target_has_execution)
          ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
  	      *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i]);
        regaddr += sizeof (PTRACE_XFER_TYPE);
diff -r -b -c -N origdb/i386bsd-nat.c gdb/i386bsd-nat.c
*** origdb/i386bsd-nat.c	Sat Jul 21 20:16:44 2001
--- gdb/i386bsd-nat.c	Wed Jan 23 10:18:46 2002
***************
*** 236,243 ****
  {
    struct dbreg dbregs;
  
!   if (ptrace (PT_GETDBREGS, PIDGET (inferior_ptid),
!               (PTRACE_ARG3_TYPE) &dbregs, 0) == -1)
      perror_with_name ("Couldn't get debug registers");
  
    /* For some mysterious reason, some of the reserved bits in the
--- 236,244 ----
  {
    struct dbreg dbregs;
  
!   if (target_has_execution
!       && (PT_GETDBREGS, PIDGET (inferior_ptid),
!               (PTRACE_ARG3_TYPE) &dbregs, 0) == -1))
      perror_with_name ("Couldn't get debug registers");
  
    /* For some mysterious reason, some of the reserved bits in the
***************
*** 247,254 ****
  
    DBREG_DRX ((&dbregs), regnum) = value;
  
!   if (ptrace (PT_SETDBREGS, PIDGET (inferior_ptid),
!               (PTRACE_ARG3_TYPE) &dbregs, 0) == -1)
      perror_with_name ("Couldn't write debug registers");
  }
  
--- 248,256 ----
  
    DBREG_DRX ((&dbregs), regnum) = value;
  
!   if (target_has_execution
!       && (PT_SETDBREGS, PIDGET (inferior_ptid),
!               (PTRACE_ARG3_TYPE) &dbregs, 0) == -1))
      perror_with_name ("Couldn't write debug registers");
  }
  
diff -r -b -c -N origdb/p-exp.y gdb/p-exp.y
*** origdb/p-exp.y	Sat Nov 10 18:06:12 2001
--- gdb/p-exp.y	Wed Jan 23 11:14:23 2002
***************
*** 1349,1354 ****
--- 1349,1364 ----
                    tokstart[i] -= ('A'-'a');
              }
        }
+      /* Finally, uppercase for Free Pascal.  */
+     if (!sym)
+       {
+          for (i = 0; i <= namelen; i++)
+            {
+              if ((tokstart[i] >= 'a' && tokstart[i] <= 'z'))
+                   tokstart[i] -= ('a'-'A');
+             }
+       }
+ 
     /* Call lookup_symtab, not lookup_partial_symtab, in case there are
         no psymtabs (coff, xcoff, or some future change to blow away the
         psymtabs once once symbols are read).  */
diff -r -b -c -N origdb/win32-nat.c gdb/win32-nat.c
*** origdb/win32-nat.c	Sat Oct 20 05:13:17 2001
--- gdb/win32-nat.c	Wed Jan 23 11:20:51 2002
***************
*** 65,70 ****
--- 65,81 ----
  #include <sys/procfs.h>
  #include <psapi.h>
  
+ #ifdef HAVE_SSE_REGS
+ #define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
+ 	| CONTEXT_EXTENDED_REGISTERS
+ #else
+ #define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS
+ #endif
+ 
+ static unsigned dr[8];
+ static int debug_registers_changed = 0;
+ static int debug_registers_used = 0;
+ 
  /* The string sent by cygwin when it processes a signal.
     FIXME: This should be in a cygwin include file. */
  #define CYGWIN_SIGNAL_STRING "cygwin: signal"
***************
*** 168,177 ****
--- 179,207 ----
    context_offset (FloatSave.DataSelector),
    context_offset (FloatSave.DataOffset),
    context_offset (FloatSave.ErrorSelector)
+ #ifdef HAVE_SSE_REGS
+   /* XMM0-7 */ ,
+   context_offset (ExtendedRegisters[10*16]),
+   context_offset (ExtendedRegisters[11*16]),
+   context_offset (ExtendedRegisters[12*16]),
+   context_offset (ExtendedRegisters[13*16]),
+   context_offset (ExtendedRegisters[14*16]),
+   context_offset (ExtendedRegisters[15*16]),
+   context_offset (ExtendedRegisters[16*16]),
+   context_offset (ExtendedRegisters[17*16]),
+   /* MXCSR */
+   context_offset (ExtendedRegisters[24])
+ #endif
  };
  
  #undef context_offset
  
+ void
+ check (BOOL ok, const char *file, int line)
+ { if (!ok)
+     printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
+ }
+ 
  /* This vector maps the target's idea of an exception (extracted
     from the DEBUG_EVENT structure) to GDB's idea. */
  
***************
*** 209,215 ****
  	    else if (get_context < 0)
  	      th->suspend_count = -1;
  
! 	    th->context.ContextFlags = CONTEXT_DEBUGGER;
  	    GetThreadContext (th->h, &th->context);
  	  }
  	return th;
--- 239,255 ----
  	    else if (get_context < 0)
  	      th->suspend_count = -1;
  
!             th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
! 	    if (id == current_event.dwThreadId)
! 	      {
!  		/* Copy dr values from that thread.  */
!  		dr[0] = th->context.Dr0;
!  		dr[1] = th->context.Dr1;
!  		dr[2] = th->context.Dr2;
!  		dr[3] = th->context.Dr3;
!  		dr[6] = th->context.Dr6;
!  		dr[7] = th->context.Dr7;
!  	      }
  	    GetThreadContext (th->h, &th->context);
  	  }
  	return th;
***************
*** 233,238 ****
--- 273,294 ----
    th->h = h;
    th->next = thread_head.next;
    thread_head.next = th;
+   /* Set the debug registers for the new thread in they are used.  */
+   if (debug_registers_used)
+     {
+       /* Only change the value of the debug registers.  */
+       th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+       CHECK (GetThreadContext (th->h, &th->context));
+       th->context.Dr0 = dr[0];
+       th->context.Dr1 = dr[1];
+       th->context.Dr2 = dr[2];
+       th->context.Dr3 = dr[3];
+       /* th->context.Dr6 = dr[6];
+       FIXME: should we set dr6 also ?? */
+       th->context.Dr7 = dr[7];
+       CHECK (SetThreadContext (th->h, &th->context));
+       th->context.ContextFlags = 0;
+     }
    add_thread (pid_to_ptid (id));
    return th;
  }
***************
*** 280,292 ****
  }
  
  static void
- check (BOOL ok, const char *file, int line)
- {
-   if (!ok)
-     printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
- }
- 
- static void
  do_child_fetch_inferior_registers (int r)
  {
    char *context_offset = ((char *) &current_thread->context) + mappings[r];
--- 336,341 ----
***************
*** 765,770 ****
--- 814,825 ----
         (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
        ourstatus->value.sig = TARGET_SIGNAL_TRAP;
        break;
+     case DBG_CONTROL_BREAK:
+       DEBUG_EXCEPT (("gdb: Target exception CONTROL_BREAK at 0x%08lx\n",
+        (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
+       ourstatus->value.sig = TARGET_SIGNAL_INT;
+       last_sig = SIGINT;	/* FIXME - should check pass state */
+       break;
      case DBG_CONTROL_C:
        DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08lx\n",
         (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
***************
*** 993,1000 ****
--- 1048,1060 ----
  static void
  do_initial_child_stuff (DWORD pid)
  {
+   int i;
    extern int stop_after_trap;
  
+   debug_registers_changed = 0;
+   debug_registers_used = 0;
+   for (i = 0; i <= 7; i++)
+     dr[i] = 0;
    last_sig = 0;
    event_count = 0;
    exception_count = 0;
***************
*** 1294,1302 ****
  child_resume (ptid_t ptid, int step, enum target_signal sig)
  {
    thread_info *th;
!   DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
!   DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
    int pid = PIDGET (ptid);
  
    last_sig = 0;
  
--- 1354,1376 ----
  child_resume (ptid_t ptid, int step, enum target_signal sig)
  {
    thread_info *th;
!   DWORD continue_status =  DBG_CONTINUE;
    int pid = PIDGET (ptid); 
+   if (((sig == TARGET_SIGNAL_INT)
+        && (last_sig == SIGINT))
+          || ((sig == TARGET_SIGNAL_SEGV)
+        && (last_sig == SIGSEGV))
+          || ((sig == TARGET_SIGNAL_ILL)
+        && (last_sig == SIGILL))
+        || ((sig == TARGET_SIGNAL_FPE)
+        && (last_sig == SIGFPE)))
+     continue_status = DBG_EXCEPTION_NOT_HANDLED;
+ 
+   if (sig && continue_status == DBG_CONTINUE)
+     {
+       /* Warn that we can not send this signal */
+       printf ("Unable to send signal %d to debuggee",sig);
+     }
  
    last_sig = 0;
  
***************
*** 1307,1312 ****
--- 1381,1396 ----
    th = thread_rec (current_event.dwThreadId, FALSE);
    if (th)
      {
+       if (debug_registers_changed)
+         {
+           th->context.Dr0 = dr[0];
+           th->context.Dr1 = dr[1];
+           th->context.Dr2 = dr[2];
+           th->context.Dr3 = dr[3];
+           /* th->context.Dr6 = dr[6];
+            FIXME: should we set dr6 also ?? */
+           th->context.Dr7 = dr[7];
+         }
        if (step)
  	{
  	  /* Single step by setting t bit */
***************
*** 1449,1454 ****
--- 1533,1575 ----
  
    add_target (&child_ops);
  }
+ 
+ /* Hardware watchpoint support, adapted from go32-nat.c code.  */
+ 
+ /* Pass the address ADDR to the inferior in the I'th debug register.
+    Here we just store the address in dr array, the registers will be
+    actually set up when child_continue is called.  */
+ void
+ cygwin_set_dr (int i, CORE_ADDR addr)
+ {
+   if (i < 0 || i > 3)
+     internal_error (__FILE__, __LINE__,
+ 		    "Invalid register %d in cygwin_set_dr.\n", i);
+   dr[i] = (unsigned) addr;
+   debug_registers_changed = 1;
+   debug_registers_used = 1;
+ }
+ 
+ /* Pass the value VAL to the inferior in the DR7 debug control
+    register.  Here we just store the address in D_REGS, the watchpoint
+    will be actually set up in child_wait.  */
+ void
+ cygwin_set_dr7 (unsigned val)
+ {
+   dr[7] = val;
+   debug_registers_changed = 1;
+   debug_registers_used = 1;
+ }
+ 
+ /* Get the value of the DR6 debug status register from the inferior.
+    Here we just return the value stored in dr[6]
+    by the last call to thread_rec for current_event.dwThreadId id.  */
+ unsigned
+ cygwin_get_dr6 (void)
+ {
+   return dr[6];
+ }
+ 
  
  /* Determine if the thread referenced by "pid" is alive
     by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0
