diff -r -u -N origdb/breakpoint.c gdb/breakpoint.c
--- origdb/breakpoint.c	Wed Jan 23 12:38:06 2002
+++ gdb/breakpoint.c	Wed Jan 23 13:02:04 2002
@@ -234,6 +234,18 @@
 	     B ? (TMP=B->next, 1): 0;	\
 	     B = TMP)
 
+#ifndef REMOVE_HARDWARE_BREAKPOINT_AT_EXIT
+#define REMOVE_HARDWARE_BREAKPOINT_AT_EXIT 0
+#endif
+
+#ifndef REMOVE_HARDWARE_WATCHPOINT_AT_EXIT
+#define REMOVE_HARDWARE_WATCHPOINT_AT_EXIT 0
+#endif
+
+#ifndef HARDWARE_REGISTERS_RESET
+#define HARDWARE_REGISTERS_RESET {}
+#endif
+
 /* True if SHIFT_INST_REGS defined, false otherwise.  */
 
 int must_shift_inst_regs =
@@ -1439,6 +1451,42 @@
 
   ALL_BREAKPOINTS_SAFE (b, temp)
   {
+        /* Disabled, does not work correctly
+	if ((b->type == bp_hardware_watchpoint
+	       || b->type == bp_watchpoint
+	       || b->type == bp_access_watchpoint
+	       || b->type == bp_read_watchpoint)
+	     && (context == inf_exited))
+	 {
+	  if (b->val)
+	    value_free (b->val);
+	  b->val = NULL;
+         } */
+        if ((((REMOVE_HARDWARE_BREAKPOINT_AT_EXIT)
+		&& b->type == bp_hardware_breakpoint)
+	       ||((REMOVE_HARDWARE_WATCHPOINT_AT_EXIT)
+		  && (b->type == bp_hardware_watchpoint
+		      || b->type == bp_access_watchpoint
+	              || b->type == bp_read_watchpoint)))
+                   && b->inserted
+		   && context == inf_exited)
+   	 remove_breakpoint (b, mark_uninserted);
+
+	/* Also disabled
+	if (b->type == bp_hardware_watchpoint
+	       || b->type == bp_watchpoint
+	       || b->type == bp_access_watchpoint
+	       || b->type == bp_read_watchpoint)
+	{
+	  struct value * val;
+	  struct value * mark = value_mark (); 
+	  val = evaluate_expression (b->exp);
+	  release_value (val);
+	  if (VALUE_LAZY (val))
+	   value_fetch_lazy (val);
+	  b->val = val;
+	  value_free_to_mark (mark);
+	 } */
     b->inserted = 0;
 
     switch (b->type)
@@ -7134,8 +7182,9 @@
 	    xfree (b->cond);
 	  b->cond = parse_exp_1 (&s, (struct block *) 0, 0);
 	}
-      if (b->enable_state == bp_enabled)
-	mention (b);
+      /* Generates lot of noise
+	if (b->enable_state == bp_enabled)
+	mention (b); */
       value_free_to_mark (mark);
       break;
     case bp_catch_catch:
diff -r -u -N origdb/config/i386/cygwin.mh gdb/config/i386/cygwin.mh
--- origdb/config/i386/cygwin.mh	Wed Jan 23 12:37:59 2002
+++ gdb/config/i386/cygwin.mh	Wed Jan 23 13:02:04 2002
@@ -1,6 +1,6 @@
 MH_CFLAGS=
 XM_FILE=xm-cygwin.h
 XDEPFILES=
-NATDEPFILES= win32-nat.o corelow.o
-NAT_FILE=../none/nm-none.h
+NATDEPFILES= i386-nat.o win32-nat.o corelow.o
+NAT_FILE=nm-cygwin.h
 XM_CLIBS=
diff -r -u -N origdb/config/i386/nm-cygwin.h gdb/config/i386/nm-cygwin.h
--- origdb/config/i386/nm-cygwin.h	Thu Jan  1 01:00:00 1970
+++ gdb/config/i386/nm-cygwin.h	Wed Jan 23 13:02:04 2002
@@ -0,0 +1,38 @@
+/* Native definitions for Intel x86 running CYGWIN.
+   Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define NO_PTRACE_H
+
+#define I386_USE_GENERIC_WATCHPOINTS
+
+#include "i386/nm-i386.h"
+
+/* Support for hardware-assisted breakpoints and watchpoints.  */
+
+#define I386_DR_LOW_SET_CONTROL(VAL)	cygwin_set_dr7 (VAL)
+extern void cygwin_set_dr7 (unsigned);
+
+#define I386_DR_LOW_SET_ADDR(N,ADDR)	cygwin_set_dr (N,ADDR)
+extern void cygwin_set_dr (int, CORE_ADDR);
+
+#define I386_DR_LOW_RESET_ADDR(N)
+
+#define I386_DR_LOW_GET_STATUS()	cygwin_get_dr6 ()
+extern unsigned cygwin_get_dr6 (void);
diff -r -u -N origdb/config/i386/nm-i386.h gdb/config/i386/nm-i386.h
--- origdb/config/i386/nm-i386.h	Wed Jan 23 12:37:59 2002
+++ gdb/config/i386/nm-i386.h	Wed Jan 23 13:02:04 2002
@@ -115,6 +115,12 @@
 
 #define DECR_PC_AFTER_HW_BREAK 0
 
+#define REMOVE_HARDWARE_WATCHPOINT_AT_EXIT 1
+
+#define REMOVE_HARDWARE_BREAKPOINT_AT_EXIT 1
+
+#define HARDWARE_REGISTERS_RESET i386_cleanup_dregs ()
+
 #endif /* I386_USE_GENERIC_WATCHPOINTS */
 
 #endif /* NM_I386_H */
diff -r -u -N origdb/go32-nat.c gdb/go32-nat.c
--- origdb/go32-nat.c	Wed Jan 23 12:38:06 2002
+++ gdb/go32-nat.c	Wed Jan 23 13:02:04 2002
@@ -674,7 +674,7 @@
      be nice if GDB itself would take care to remove all breakpoints
      at all times, but it doesn't, probably under an assumption that
      the OS cleans up when the debuggee exits.  */
-  i386_cleanup_dregs ();
+  // i386_cleanup_dregs (); done in breakpoint_init_inferior
   go32_kill_inferior ();
   generic_mourn_inferior ();
 }
@@ -698,7 +698,7 @@
 go32_set_dr (int i, CORE_ADDR addr)
 {
   if (i < 0 || i > 3)
-    internal_error (__FILE__, __LINE__, 
+    internal_error (__FILE__, __LINE__,
 		    "Invalid register %d in go32_set_dr.\n", i);
   D_REGS[i] = addr;
 }
diff -r -u -N origdb/i386-linux-nat.c gdb/i386-linux-nat.c
--- origdb/i386-linux-nat.c	Wed Jan 23 12:37:56 2002
+++ gdb/i386-linux-nat.c	Wed Jan 23 13:02:04 2002
@@ -259,12 +259,13 @@
   for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
     {
       errno = 0;
-      ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
+      if (target_has_execution)
+        ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
 	      *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i]);
       regaddr += sizeof (PTRACE_XFER_TYPE);
       if (errno != 0)
 	{
-	  sprintf (mess, "writing register %s (#%d)", 
+	  sprintf (mess, "writing register %s (#%d)",
 		   REGISTER_NAME (regno), regno);
 	  perror_with_name (mess);
 	}
diff -r -u -N origdb/i386bsd-nat.c gdb/i386bsd-nat.c
--- origdb/i386bsd-nat.c	Wed Jan 23 12:37:54 2002
+++ gdb/i386bsd-nat.c	Wed Jan 23 13:02:04 2002
@@ -236,8 +236,9 @@
 {
   struct dbreg dbregs;
 
-  if (ptrace (PT_GETDBREGS, PIDGET (inferior_ptid),
-              (PTRACE_ARG3_TYPE) &dbregs, 0) == -1)
+  if (target_has_execution
+      && (PT_GETDBREGS, PIDGET (inferior_ptid),
+              (PTRACE_ARG3_TYPE) &dbregs, 0) == -1))
     perror_with_name ("Couldn't get debug registers");
 
   /* For some mysterious reason, some of the reserved bits in the
@@ -247,8 +248,9 @@
 
   DBREG_DRX ((&dbregs), regnum) = value;
 
-  if (ptrace (PT_SETDBREGS, PIDGET (inferior_ptid),
-              (PTRACE_ARG3_TYPE) &dbregs, 0) == -1)
+  if (target_has_execution
+      && (PT_SETDBREGS, PIDGET (inferior_ptid),
+              (PTRACE_ARG3_TYPE) &dbregs, 0) == -1))
     perror_with_name ("Couldn't write debug registers");
 }
 
diff -r -u -N origdb/p-exp.y gdb/p-exp.y
--- origdb/p-exp.y	Thu Jan 24 09:20:03 2002
+++ gdb/p-exp.y	Thu Mar 28 17:12:09 2002
@@ -1300,7 +1300,7 @@
 			 &is_a_field_of_this,
 			 (struct symtab **) NULL);
     /* second chance uppercased (as Free Pascal does).  */
-    if (!sym)
+    if (!sym && !is_a_field_of_this)
       {
        for (i = 0; i <= namelen; i++)
          {
@@ -1318,8 +1318,8 @@
                tokstart[i] -= ('a'-'A');
            }
       }
-    /* Third chance Capitalized (as GPC does).  */
-    if (!sym)
+     /* Third chance Capitalized (as GPC does).  */
+    if (!sym && !is_a_field_of_this)
       {
        for (i = 0; i <= namelen; i++)
          {
@@ -1349,7 +1349,17 @@
                   tokstart[i] -= ('A'-'a');
             }
       }
-    /* Call lookup_symtab, not lookup_partial_symtab, in case there are
+     /* Finally, uppercase for Free Pascal.  */
+    if (!sym && !is_a_field_of_this)
+      {
+         for (i = 0; i <= namelen; i++)
+           {
+             if ((tokstart[i] >= 'a' && tokstart[i] <= 'z'))
+                  tokstart[i] -= ('a'-'A');
+            }
+      }
+
+   /* Call lookup_symtab, not lookup_partial_symtab, in case there are
        no psymtabs (coff, xcoff, or some future change to blow away the
        psymtabs once once symbols are read).  */
     if ((sym && SYMBOL_CLASS (sym) == LOC_BLOCK) ||
diff -r -u -N origdb/win32-nat.c gdb/win32-nat.c
--- origdb/win32-nat.c	Wed Jan 23 12:37:56 2002
+++ gdb/win32-nat.c	Wed Jan 23 13:02:04 2002
@@ -65,6 +65,17 @@
 #include <sys/procfs.h>
 #include <psapi.h>
 
+#ifdef HAVE_SSE_REGS
+#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS \
+	| CONTEXT_EXTENDED_REGISTERS
+#else
+#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS
+#endif
+
+static unsigned dr[8];
+static int debug_registers_changed = 0;
+static int debug_registers_used = 0;
+
 /* The string sent by cygwin when it processes a signal.
    FIXME: This should be in a cygwin include file. */
 #define CYGWIN_SIGNAL_STRING "cygwin: signal"
@@ -168,10 +179,29 @@
   context_offset (FloatSave.DataSelector),
   context_offset (FloatSave.DataOffset),
   context_offset (FloatSave.ErrorSelector)
+#ifdef HAVE_SSE_REGS
+  /* XMM0-7 */ ,
+  context_offset (ExtendedRegisters[10*16]),
+  context_offset (ExtendedRegisters[11*16]),
+  context_offset (ExtendedRegisters[12*16]),
+  context_offset (ExtendedRegisters[13*16]),
+  context_offset (ExtendedRegisters[14*16]),
+  context_offset (ExtendedRegisters[15*16]),
+  context_offset (ExtendedRegisters[16*16]),
+  context_offset (ExtendedRegisters[17*16]),
+  /* MXCSR */
+  context_offset (ExtendedRegisters[24])
+#endif
 };
 
 #undef context_offset
 
+void
+check (BOOL ok, const char *file, int line)
+{ if (!ok)
+    printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
+}
+
 /* This vector maps the target's idea of an exception (extracted
    from the DEBUG_EVENT structure) to GDB's idea. */
 
@@ -209,7 +239,17 @@
 	    else if (get_context < 0)
 	      th->suspend_count = -1;
 
-	    th->context.ContextFlags = CONTEXT_DEBUGGER;
+            th->context.ContextFlags = CONTEXT_DEBUGGER_DR;
+	    if (id == current_event.dwThreadId)
+	      {
+ 		/* Copy dr values from that thread.  */
+ 		dr[0] = th->context.Dr0;
+ 		dr[1] = th->context.Dr1;
+ 		dr[2] = th->context.Dr2;
+ 		dr[3] = th->context.Dr3;
+ 		dr[6] = th->context.Dr6;
+ 		dr[7] = th->context.Dr7;
+ 	      }
 	    GetThreadContext (th->h, &th->context);
 	  }
 	return th;
@@ -233,6 +273,22 @@
   th->h = h;
   th->next = thread_head.next;
   thread_head.next = th;
+  /* Set the debug registers for the new thread in they are used.  */
+  if (debug_registers_used)
+    {
+      /* Only change the value of the debug registers.  */
+      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
+      CHECK (GetThreadContext (th->h, &th->context));
+      th->context.Dr0 = dr[0];
+      th->context.Dr1 = dr[1];
+      th->context.Dr2 = dr[2];
+      th->context.Dr3 = dr[3];
+      /* th->context.Dr6 = dr[6];
+      FIXME: should we set dr6 also ?? */
+      th->context.Dr7 = dr[7];
+      CHECK (SetThreadContext (th->h, &th->context));
+      th->context.ContextFlags = 0;
+    }
   add_thread (pid_to_ptid (id));
   return th;
 }
@@ -280,13 +336,6 @@
 }
 
 static void
-check (BOOL ok, const char *file, int line)
-{
-  if (!ok)
-    printf_filtered ("error return %s:%d was %lu\n", file, line, GetLastError ());
-}
-
-static void
 do_child_fetch_inferior_registers (int r)
 {
   char *context_offset = ((char *) &current_thread->context) + mappings[r];
@@ -343,7 +392,7 @@
 static BOOL WINAPI (*psapi_GetModuleInformation) (HANDLE, HMODULE, LPMODULEINFO, DWORD) = NULL;
 static DWORD WINAPI (*psapi_GetModuleFileNameExA) (HANDLE, HMODULE, LPSTR, DWORD) = NULL;
 
-int 
+int
 psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
 {
   DWORD len;
@@ -765,6 +814,12 @@
        (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
       ourstatus->value.sig = TARGET_SIGNAL_TRAP;
       break;
+    case DBG_CONTROL_BREAK:
+      DEBUG_EXCEPT (("gdb: Target exception CONTROL_BREAK at 0x%08lx\n",
+       (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
+      ourstatus->value.sig = TARGET_SIGNAL_INT;
+      last_sig = SIGINT;	/* FIXME - should check pass state */
+      break;
     case DBG_CONTROL_C:
       DEBUG_EXCEPT (("gdb: Target exception CONTROL_C at 0x%08lx\n",
        (DWORD) current_event.u.Exception.ExceptionRecord.ExceptionAddress));
@@ -993,8 +1048,13 @@
 static void
 do_initial_child_stuff (DWORD pid)
 {
+  int i;
   extern int stop_after_trap;
 
+  debug_registers_changed = 0;
+  debug_registers_used = 0;
+  for (i = 0; i <= 7; i++)
+    dr[i] = 0;
   last_sig = 0;
   event_count = 0;
   exception_count = 0;
@@ -1294,9 +1354,23 @@
 child_resume (ptid_t ptid, int step, enum target_signal sig)
 {
   thread_info *th;
-  DWORD continue_status = last_sig > 0 && last_sig < NSIG ?
-  DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;
-  int pid = PIDGET (ptid);
+  DWORD continue_status =  DBG_CONTINUE;
+  int pid = PIDGET (ptid); 
+  if (((sig == TARGET_SIGNAL_INT)
+       && (last_sig == SIGINT))
+         || ((sig == TARGET_SIGNAL_SEGV)
+       && (last_sig == SIGSEGV))
+         || ((sig == TARGET_SIGNAL_ILL)
+       && (last_sig == SIGILL))
+       || ((sig == TARGET_SIGNAL_FPE)
+       && (last_sig == SIGFPE)))
+    continue_status = DBG_EXCEPTION_NOT_HANDLED;
+
+  if (sig && continue_status == DBG_CONTINUE)
+    {
+      /* Warn that we can not send this signal */
+      printf ("Unable to send signal %d to debuggee",sig);
+    }
 
   last_sig = 0;
 
@@ -1307,6 +1381,16 @@
   th = thread_rec (current_event.dwThreadId, FALSE);
   if (th)
     {
+      if (debug_registers_changed)
+        {
+          th->context.Dr0 = dr[0];
+          th->context.Dr1 = dr[1];
+          th->context.Dr2 = dr[2];
+          th->context.Dr3 = dr[3];
+          /* th->context.Dr6 = dr[6];
+           FIXME: should we set dr6 also ?? */
+          th->context.Dr7 = dr[7];
+        }
       if (step)
 	{
 	  /* Single step by setting t bit */
@@ -1449,6 +1533,43 @@
 
   add_target (&child_ops);
 }
+
+/* Hardware watchpoint support, adapted from go32-nat.c code.  */
+
+/* Pass the address ADDR to the inferior in the I'th debug register.
+   Here we just store the address in dr array, the registers will be
+   actually set up when child_continue is called.  */
+void
+cygwin_set_dr (int i, CORE_ADDR addr)
+{
+  if (i < 0 || i > 3)
+    internal_error (__FILE__, __LINE__,
+		    "Invalid register %d in cygwin_set_dr.\n", i);
+  dr[i] = (unsigned) addr;
+  debug_registers_changed = 1;
+  debug_registers_used = 1;
+}
+
+/* Pass the value VAL to the inferior in the DR7 debug control
+   register.  Here we just store the address in D_REGS, the watchpoint
+   will be actually set up in child_wait.  */
+void
+cygwin_set_dr7 (unsigned val)
+{
+  dr[7] = val;
+  debug_registers_changed = 1;
+  debug_registers_used = 1;
+}
+
+/* Get the value of the DR6 debug status register from the inferior.
+   Here we just return the value stored in dr[6]
+   by the last call to thread_rec for current_event.dwThreadId id.  */
+unsigned
+cygwin_get_dr6 (void)
+{
+  return dr[6];
+}
+
 
 /* Determine if the thread referenced by "pid" is alive
    by "polling" it.  If WaitForSingleObject returns WAIT_OBJECT_0
diff -r -u -N origdb/top.c gdb/top.c
--- origdb/top.c   Sun Oct 21 20:41:18 2001
+++ gdb/top.c	Thu Mar 14 00:40:00 2002
@@ -1228,7 +1228,7 @@
      program to parse, and is just canonical program name and version
      number, which starts after last space. */
 
-  fprintf_filtered (stream, "GNU gdb %s\n", version);
+  fprintf_filtered (stream, "GNU gdb %s adapted to Free Pascal\n", version);
 
   /* Second line is a copyright notice. */
 
